# 429背景

ARINC 429 总线是航空电子领域经典的 **单向串行数据总线标准**（也常称 “429 总线”），由国际航空无线电协会（ARINC）制定，编号 ARINC 429-19，是 20 世纪 70 年代至今航空电子系统中应用最广泛的总线之一，主要用于机载设备间的低速、关键数据传输。

### 一、核心定位：早期航电的 “数据骨干”

ARINC 429 诞生的核心需求是解决早期航空电子设备（如导航、飞控、发动机控制、显示系统）的 “互联互通”—— 当时缺乏统一的通信标准，设备间数据传输混乱，429 总线通过标准化的电气特性、数据格式和传输规则，成为民航客机（如波音 737/747、空客 A320/A330 早期型号）、军用飞机等的主流通信总线。

它的设计理念是 “简单可靠、实时可控”，虽速率和容量不及后续的 ARINC 664，但胜在成熟稳定、抗干扰能力强，至今仍在大量现役飞机中服役（部分新机型仍保留 429 接口用于兼容 legacy 设备）。

### 二、关键技术特点（与 ARINC 664 对比鲜明）

#### 1. 拓扑结构：单向点对点 / 多点广播

- 核心是 **单向传输**：一条 429 总线链路只能 “一收多发” 或 “一发多收”—— 一个发送端（源设备）可连接最多 20 个接收端（目标设备），但接收端无法向发送端回传数据（若需双向通信，需单独铺设反向的 429 链路）。
- 无交换机 / 路由器：直接通过屏蔽双绞线连接设备，结构简单，故障点少，适合关键数据的 “点对点专属传输”。

#### 2. 电气特性与传输速率

- 传输介质：双绞屏蔽线（两根信号线 + 屏蔽层），减少电磁干扰（EMI），适配机载复杂电磁环境。
- 速率分级：
  - 低速级：12.5 kbps（用于非实时数据，如设备状态监控）；
  - 高速级：100 kbps（用于实时性要求较高的数据，如飞行姿态、导航参数）。
- 信号形式：采用 **双极性归零码（BPRZ）**—— 高电平（+6~+10V）、低电平（-6~-10V）、零电平交替表示逻辑，抗干扰能力强，且能通过信号极性判断数据有效性。

#### 3. 数据格式：固定 32 位帧结构（标准化极强）

每帧数据固定为 32 位，格式严格统一，接收端可直接解析，无需复杂协议协商：

| 位段     | 功能说明                                                     |
| -------- | ------------------------------------------------------------ |
| 1~8 位   | 标签（Label）：标识数据含义（如 “气压高度”“空速”“航向角”），共 256 种组合 |
| 9~10 位  | 源 / 目的标识（SDI）：区分同一标签下的不同数据源或接收目标   |
| 11~28 位 | 数据字段（Data）：实际有效数据（二进制 / BCD 码）            |
| 29~31 位 | 状态位（SSM）：标识数据状态（如 “有效”“失效”“测试模式”）     |
| 32 位    | 奇偶校验位（Parity）：奇校验，确保数据传输完整性             |

例：飞行控制计算机发送 “当前航向角 123.5°”，会通过固定标签（如 Label=0x12）、数据字段（123.5° 编码）、状态位（“有效”）组成 32 位帧，接收端（如座舱显示系统）通过标签直接识别数据含义，无需额外解析协议。

#### 4. 可靠性设计

- 无总线竞争：单向传输 + 固定帧结构，避免多个设备同时发送导致的冲突；
- 抗干扰：双绞屏蔽线 + 双极性信号，降低机载电磁干扰对数据的影响；
- 简单故障排查：链路结构单一，设备故障仅影响对应链路，不扩散至整个网络。

### 三、数据收发流程（极简且固定）

#### 1. 数据发送

1. 源设备（如导航计算机）生成业务数据（如经纬度）；
2. 按照 32 位帧格式，将数据编码为 “标签 + SDI + 数据 + SSM + 校验位” 的二进制流；
3. 总线控制器将二进制流转换为双极性归零码（电信号）；
4. 通过屏蔽双绞线发送给所有连接的接收端。

#### 2. 数据接收

1. 接收设备（如座舱显示器）通过总线接口接收双极性电信号；
2. 先通过奇偶校验位验证数据完整性，若校验失败则丢弃该帧；
3. 解析标签（Label）识别数据含义，提取数据字段并解码；
4. 根据 SSM 状态位判断数据是否有效，有效则用于业务处理（如显示），无效则标记异常。

### 四、应用场景与局限

#### 1. 典型应用

- 传输低速、周期性的关键数据：如飞行姿态（俯仰角、滚转角）、导航参数（经纬度、高度）、发动机状态（转速、油温）、座舱控制指令等；
- 代表机型：波音 737 系列、空客 A320 早期型号、F-16 战斗机等（新机型如波音 787、空客 A380 以 ARINC 664 为主，但仍保留 429 接口兼容老设备）。

#### 2. 核心局限（也催生了 ARINC 664）

- 单向传输：双向通信需额外布线，增加机身重量和复杂度；
- 速率低：最高 100 kbps，无法满足现代航电 “海量数据传输”（如高清显示、传感器融合、以太网级交互）需求；
- 灵活性差：拓扑固定，新增设备需重新布线，扩展性弱；
- 单链路容量有限：一条链路仅能传输一类 / 几类固定标签的数据，多数据类型需多条链路。

### 五、与 ARINC 664（AFDX）的核心区别

| 对比维度 | ARINC 429                         | ARINC 664（AFDX）                |
| -------- | --------------------------------- | -------------------------------- |
| 拓扑结构 | 单向点对点 / 多点广播（无交换机） | 星形拓扑（端系统 + 交换机）      |
| 传输方向 | 单向（双向需双链路）              | 全双工（双向同时传输）           |
| 传输速率 | 12.5/100 kbps                     | 100 Mbps（100Base-TX）           |
| 数据格式 | 固定 32 位帧                      | 以太网帧 + 虚拟链路（VL）封装    |
| 核心优势 | 简单可靠、抗干扰、成本低          | 高速、大容量、灵活扩展、QoS 保障 |
| 适用场景 | 低速关键数据（导航、姿态）        | 高速海量数据（飞控、传感器融合） |

简单说：**ARINC 429 是 “老而稳” 的低速串行总线，ARINC 664 是 “新而强” 的以太网基总线**，二者在航空电子系统中形成 “互补”—— 老设备 / 低速数据用 429，新设备 / 高速数据用 664。

总结：ARINC 429 总线以 “标准化、高可靠、低复杂度” 成为航空电子领域的 “经典标杆”，虽受限于速率和拓扑，但至今仍是现役飞机不可或缺的通信总线，其设计理念也为后续航电总线的可靠性设计提供了参考。



案例：

### 2.1 故障诊断









#### 2.1.1 故障组包规范





**429通信规范组包流程：**

所有组包规范都参考对应xlsx文件，故障消息组包规范参考《失效对应端口信息文件》，下图为组包时参考文件解释：

- StartBit：起始位（故障消息的StartBit=StopBit）；
- StopBit：终止位（故障消息的StartBit=StopBit）；
- FaultName：对应EOICD中的DP_Name（每一个故障都对应一个StartBit和StopBit）；
- Port_ID：消息发送的端口号，也是AHMU接收端口号（图中该消息对应UDP端口号35277）；
- TotalLength：消息字节长度（图中消息字节长度60个字节，对应消息长度60*8位）；
- Message_Name：对应消息EOICD中的Message_Name（图中消息名称pipo429_OA_1000）；
- Message_Type：消息类型（图中消息类型为ARINC 429）；
- ATA：对应的ATA；

![1763689145816](ARINC429.assets/1763689145816-1763706324560.png)

组包时：

- pipo429_OA_1000消息的总长度为TotalLength×8，即60×8
- 每一个修改位都对应一个故障
  - 第174位对应故障：Pressure_Sensor_Test_FAIL
  - 第182位对应故障：Aircraft_Cab_Press_Disagree
  - 第117位对应故障：CBV_DRIVING_FAILURE
  - 第122位对应故障：APU_BLEED_FAULT
  - 第398位对应故障：FWD_CAR_TS_CH_FAIL
  - 第305位对应故障：DISCRETE_INPUT_DISAGREE
  - 第88位对应故障：AFT_AVENTS_FAIL
  - 第90位对应故障：AFT_AVENTS_DISAGREE
  - 第430位对应故障：FWD_CAR_TS_FAIL

协议修改时，按照每32位一组，组内从右向左计数，字节序反转，pipo429_OA_1000消息修改后发送的指令如下：

```c
size_t bit_positions[] = {88,90,117,122,174,182,305,398,430}; // 示例修改位
原始二进制: 
00000000 00000000 00000000 00000000
00000011 00000011 00000011 00000011
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
原始十六进制: 
00 00 00 00
03 03 03 03
00 00 00 00
00 00 00 00
00 00 00 00
00 00 00 00
00 00 00 00
00 00 00 00
00 00 00 00
00 00 00 00
00 00 00 00
00 00 00 00
00 00 00 00
00 00 00 00
00 00 00 00
修改后二进制: 
00000000 00000000 00000000 00000000
00000011 00000011 00000011 00000011
00000000 00000000 00000000 00000101
00000000 00000000 00100000 00000100
00000000 00000000 00000000 00000000
00000000 01000000 01000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000010 00000000 00000000
00000000 00000000 00000000 00000000
01000000 00000000 00000000 00000000
01000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
修改后十六进制: 
00 00 00 00
03 03 03 03
00 00 00 05
00 00 20 04
00 00 00 00
00 40 40 00
00 00 00 00
00 00 00 00
00 00 02 00
00 00 00 00
40 00 00 00
40 00 00 00
00 00 00 00
00 00 00 00
00 00 00 00
```

端口35734对应组包：

```c
原始数据：
00000000 00000000 00000000 00000000     00 00 00 00
00000011 00000011 00000011 00000011     03 03 03 03
00011111 11111111 11111100 11101101     1F FF FC ED
00011111 11111111 11111100 11101011     1F FF FC EB
00011111 11111111 11111100 11101100     1F FF FC EC
00011111 11111111 11111100 11101010     1F FF FC EA
00000011 00000011 00000011 00000011     03 03 03 03
00011111 11111111 11111100 11101000     1F FF FC E8 
00011111 11111111 11111100 11101001     1F FF FC E9

反转数据：
00000000 00000000 00000000 00000000     00 00 00 00   31~0
00000011 00000011 00000011 00000011     03 03 03 03   63~32
11101101 11111100 11111111 00011111     ED FC FF 1F   95~64
11101011 11111100 11111111 00011111     EB FC FF 1F   127~96
11101100 11111100 11111111 00011111     EC FC FF 1F   159~128
11101010 11111100 11111111 00011111     EA FC FF 1F   191~160 
00000011 00000011 00000011 00000011     03 03 03 03   223~192
11101000 11111100 11111111 00011111     E8 FC FF 1F   255~224
11101001 11111100 11111111 00011111     E9 FC FF 1F   288~256

修改的位：
32、33、40、41、48、49、56、57、
64、65、66、67、68、72、73、74、75、76、77、78、79、82、83、84、85、86、87、88、90、91、93、94、95、
96、97、98、99、100、104、105、106、107、108、109、110、111、114、115、116、117、118、119、120、121、123、125、126、127、
128、129、130、131、132、136、137、138、139、140、141、142、143、146、147、148、149、150、151、154、155、157、158、159、
160、161、162、163、164、168、169、170、171、172、173、174、175、178、179、180、181、182、183、185、187、189、190、191、192、193、200、201、208、209、216、217、
224、225、226、227、228、232、233、234、235、236、237、238、239、242、243、244、245、246、247、251、253、254、255、
256、257、258、259、260、264、265、266、267、268、269、270、271、274、275、276、277、278、279、280、283、285、286、287
```



参考代码：

```c
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stddef.h>

/**
 * 把多个位统一设置为同一值（0 或 1）
 *
 * data: 数据缓冲区，每个元素 0/1
 * len:  数据长度（位数）
 * bitPositions: 要修改的位索引数组（从0开始）
 * count: bitPositions 的长度
 * bitValue: 要写入的值（0 -> 清 0，非0 -> 置 1）
 */
void modify_protocol_bits_bin(int *data, size_t len,
                              const size_t *bitPositions, size_t count,
                              int bitValue)
{
    if (!data || (count > 0 && !bitPositions)) return;
    if (len < 32) {
        if (count > 0) fprintf(stderr, "Warning: data too short (less than 32 bits)\n");
        return;
    }

    size_t groups = len / 32; // 每32位一组

    for (size_t g = 0; g < groups; ++g) {
        size_t base = g * 32;

        // 字节序反转，每4字节32位
        int rev[32];
        for (int b = 0; b < 4; ++b) {
            for (int bit = 0; bit < 8; ++bit) {
                rev[b*8 + bit] = data[base + (3-b)*8 + bit];
            }
        }

        // 修改位：组内从右往左计数
        for (size_t i = 0; i < count; ++i) {
            size_t idx = bitPositions[i];
            if (idx >= base && idx < base + 32) {
                size_t bitInGroup = idx - base;
                // 右往左数，最高位rev[0]对应组第0位，最低位rev[31]对应组第31位
                rev[31 - bitInGroup] = bitValue ? 1 : 0;
            }
        }

        // 反转回原数组
        for (int b = 0; b < 4; ++b) {
            for (int bit = 0; bit < 8; ++bit) {
                data[base + (3-b)*8 + bit] = rev[b*8 + bit];
            }
        }
    }
}


/* 打印二进制 */
void print_bin(const int *data, size_t len)
{
    for (size_t i = 0; i < len; ++i) printf("%d", data[i]);
    printf("\n");
}

/* 打印十六进制，每8位为1字节 */
void print_hex_from_bin(const int *data, size_t len)
{
    for (size_t i = 0; i < len; i += 8) {
        unsigned char byte = 0;
        for (int j = 0; j < 8 && (i+j)<len; ++j) {
            byte = (byte << 1) | (data[i+j] & 1);
        }
        printf("%02X ", byte);
    }
    printf("\n");
}

/* 示例用法 */
int main(void)
{
#ifdef _WIN32 || _WIN64
    // Windows下使用GBK或设置UTF-8
    system("chcp 65001 >nul"); // 切换终端为UTF-8
#endif

    int protocol_bits[] = {
            // 第1-4个字节：0x00
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            // 第5-8个字节：0x03
            0,0,0,0,0,0,1,1, 0,0,0,0,0,0,1,1, 0,0,0,0,0,0,1,1, 0,0,0,0,0,0,1,1,
            // 第9-12个字节：0x00
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            // 第13-16个字节：0x00
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            // 第17-20个字节：0x00
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            // 第21-24个字节：0x00
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            // 第25-28个字节：0x00
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            // 第29-32个字节：0x03
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            // 第33-36个字节：0x00
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            // 第37-40个字节：0x00
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            // 第41-44个字节：0x00
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            // 第45-48个字节：0x00
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            // 第49-52个字节：0x00
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            // 第53-56个字节：0x00
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            // 第57-60个字节：0x00
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0
    };

    size_t len = sizeof(protocol_bits)/sizeof(protocol_bits[0]);

    printf("原始二进制: ");
    print_bin(protocol_bits, len);
    printf("原始十六进制: ");
    print_hex_from_bin(protocol_bits, len);

    int bit_values[] = {0,1}; // 0/1

    size_t bit_positions[] = {88,90,117,122,174,182,305,398,430}; // 示例修改位
    size_t cnt = sizeof(bit_positions)/sizeof(bit_positions[0]);

    modify_protocol_bits_bin(protocol_bits, len, bit_positions, cnt, bit_values[1]);

    printf("修改后二进制: ");
    print_bin(protocol_bits, len);
    printf("修改后十六进制: ");
    print_hex_from_bin(protocol_bits, len);

    return 0;
}

```








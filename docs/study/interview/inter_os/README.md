<!-- tabs:start -->

#### **进程通信：**

* **`管道`**：管道是无格式的字节流数据
	* `匿名管道`：半双工单向通信，应用于**有血缘关系的进程**之间，创建管道时，操作系统会为管道分配两个文件描述符，一个用于读操作，另一个用于写操作。**亲缘关系的进程之间共享文件描述符**（子进程能继承父进程的文件描述符）。管道的本质是一块**内存缓冲区**，内部使用**环形队列**实现。匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。
	* `命名管道`：**不具有血缘关系**的进程也能交换数据，利用FIFO文件进行数据交换，创建了一个FIFO文件，就会为其分配一块内核缓冲区，操作时不能直接操作内核缓冲区，必须通过操作FIFO文件。**FIFO严格遵守先进先出**（队列），对FIFO 的**读总是从开始处返回数据**，对它们的**写则把数据添加到末尾**。
	* 管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据
* **`消息队列`**：**消息队列是保存在内核中的消息链表**，如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。消息队列的读取和写入的过程，都会有发生**用户态与内核态之间的消息拷贝**过程。
* **`共享内存`**：原本虚拟内存让每个进程都有自己独立的虚拟内存空间，**共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中**，这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去。
* **`信号量`**：**信号量**其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。信号量表示资源的数量，控制信号量的方式有两种原子操作：
	* **P 操作**：信号量减去 1，信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。
	* **V 操作**：信号量加上 1，信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；
	* 信号初始化为 `1`，就代表着是**互斥信号量**，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了**共享内存**。
	* 信号初始化为 `0`，就代表着是**同步信号量**，它可以保证进程 A 应在进程 B 之前执行


* **`信号`**：**对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。**在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。
* **`socket`**：**跨网络与不同主机上的进程之间通信，需要 Socket 通信。**本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是**绑定一个本地文件**。



#### **虚拟内存：**

内存是用来存放和交换数据的，虚拟内存是一种**内存管理技术**，它**允许操作系统在物理内存（RAM）不足时，将部分暂时不使用的数据或代码交换到磁盘（通常是硬盘或SSD）上，以此来扩展可用内存的大小**。

* 将磁盘分为4KB大小一页的页面，一部分的页面会保存在内存中，当CPU对内存进行访问时，如果访问的页面不在内存中，可以从磁盘加载对应的部分。内存不够时也可以把长期不访问的页面保存到磁盘中，这种做法叫做虚拟内存
* 将长期经常用的存放在虚拟内存的指令和数据会被系统分配虚拟地址；

虚拟内存的作用：

* **分配内存**：**虚拟内存可以使得进程对运行内存超过物理内存大小**，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
* **防止进程间相互影响**：由于**每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的**。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。



#### **多线程同步：**

同一个进程之间的多线程本就共享同一片内存空间，为了避免线程之间对共享资源的同时访问，造成混乱。

* **锁**：加锁、解锁操作；（互斥锁、自旋锁、读写锁）
	* 互斥锁（mutex）在访问资源前对互斥量（临界资源）进行加锁，访问完成后进行释放
	* 自旋锁：自旋锁是一种特殊的互斥锁，当线程尝试获取锁失败时，它会不断循环检查锁是否可用，而不是像互斥锁那样进入阻塞状态。因此自旋锁在获取锁之前一直占用cpu，只适用于短时间的等待场景，因为它避免了线程上下文切换的开销。
	* 读写锁：写独占，读共享，当一个线程持有写锁时，其他线程（无论是读还是写）都会被阻塞。当多个线程持有读锁时，写线程会被阻塞，但其他读线程可以继续访问资源。

* **条件变量：**，**条件变量可以使线程阻塞, 等待某个条件的发生, 当条件满足的时候解除阻塞**.满足条件时发送信号，唤醒响应的线程，条件变量通常和互斥量一起使用
* **信号量**：P、V 操作，



#### **锁：**

* **互斥锁：**互斥锁是一种「独占锁」当已经有一个线程加锁后，其他线程加锁则就会失败，于是就会**释放 CPU** 让给其他线程，**既然线程释放掉了 CPU，自然线程加锁的代码就会被阻塞**。**对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的**，所以，互斥锁加锁失败时，会从用户态陷入到内核态，虽然简化了使用锁的难度，但是存在一定的性能开销成本(线程的上下文切换成本)。

* **自旋锁**：自旋锁是通过 CPU 提供的 `CAS` 函数，在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程**会「忙等待」**。
	* 一般加锁的过程，包含两个步骤：
		* 第一步，查看锁的状态，如果锁是空闲的，执行第二步
		* 第二步，将锁设置为当前线程持有
		* CAS 函数就把这两个步骤合并成一条硬件级指令，形成**原子指令**

* **读写锁：**只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁，**读写锁适用于能明确区分读操作和写操作的场景**。
	* 写锁是独占锁，因为任何时刻只能有一个线程持有写锁，且加了写锁之后，**任何试图加读锁或写锁的线程都会被阻塞**，直到写者释放其写锁。
	* 读锁是共享锁，因为读锁可以被多个线程同时持有。如果线程以读模式对其加锁成功，其他线程的读锁会自动加锁成功，**读锁会阻塞写锁，但不会阻塞其他读锁**。
	* 不管优先读锁还是写锁，一直有读线程获取读锁/写锁，对方都可能会出现饿死问题，**公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队**，**，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象**。

* 悲观锁：互斥锁、自旋锁、读写锁，都是属于悲观锁，它认为**多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁**。
* 乐观锁：乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作**。
	* 我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。



#### **死锁：**

两个或多个进程在执行过程中，因争夺资源而造成的一种**互相等待**的现象,在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了**死锁**。

* 互斥条件：**多个线程不能同时使用同一个资源**
* 持有并等待条件：**线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1**。
* 不可剥夺条件：**在自己使用完资源 之前不能被其他线程获取**
* 环路等待条件：线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2

死锁的**预防**:

1.破坏互斥条件：允许资源被多个进程共享（只读文件），但是不适用于打印机这种资源（资源在某一时刻只能被一个进程占用）。

2.要求进程一次性请求所有需要的资源。但是其他进程肯能长时间等待

3.破坏循环等待条件：对资源进行编号，要求进程按编号顺序请求资源。进程 A 先请求资源1，再请求资源2。

4.破坏不可剥夺条件：允许系统强制剥夺进程持有的资源，但是，实现复杂，可能导致进程状态不一致。

死锁的**避免**：

1.**银行家算法**：在进程请求资源时，动态检查资源分配是否会导致死锁，如果会导致死锁，则拒绝请求；否则分配资源。

2.**资源有序分配**：进程按固定顺序请求资源，避免循环等待。

死锁的**解除**：

1.**资源剥夺**：强制剥夺某些进程持有的资源，分配给其他进程，可能导致进程状态不一致。

2.**进程回滚**：将某些进程回滚到安全状态，重新执行，但是实现复杂，可能导致数据丢失。

3.**终止进程**：终止一个或多个进程，释放其持有的资源，可能导致任务失败。



####  **线程共享和独立**

在同一个进程内的多个线程共享以下资源：

1. **内存空间**：所有线程共享相同的内存空间，这意味着它们可以访问相同的全局变量和静态变量。
2. **文件描述符**：打开的文件描述符在进程内的所有线程之间共享。
3. **信号处理器**：进程中设置的信号处理器对所有线程都是共享的。
4. **环境变量**：环境变量在进程内的所有线程之间共享。
5. **代码段**：进程中的所有线程共享相同的代码段，即执行的程序代码。
6. **资源限制**：如CPU时间、内存使用量等资源限制在进程内的所有线程之间共享。
7. **进程ID**：每个线程都属于一个进程，因此它们共享相同的进程ID。
8. **其他资源**：如进程的控制终端（如果存在）、进程的用户ID和组ID等。

线程独占的资源包括：

1. **线程ID**：每个线程都有自己的线程ID，这是唯一的，用于区分进程中的不同线程。
2. **寄存器集合**：每个线程有自己的一套寄存器，包括程序计数器、栈指针等，用于保存线程的执行状态。
3. **调用栈**：每个线程都有自己的调用栈，用于存储局部变量和函数调用的上下文。
4. **线程优先级**：线程可以有自己的优先级，操作系统可能会根据线程优先级来调度线程。
5. **线程局部存储（Thread-Local Storage, TLS）**：线程可以有自己的局部存储区域，用于存储线程私有的数据。
6. **状态信息**：每个线程都有自己的状态信息，如就绪、运行、阻塞等。
7. **执行栈**：虽然多个线程可能共享同一个内存空间，但每个线程都有自己的执行栈，用于存储函数调用的参数、局部变量等。
8. **互斥锁和同步机制**：线程可能使用互斥锁（mutexes）、信号量（semaphores）、条件变量（condition variables）等同步机制来保护自己的临界区，这些同步机制是线程私有的。

总的来说，线程共享大部分资源以减少资源的重复分配和提高效率，但它们也有自己的私有资源以保持独立性和线程安全。

**切换：**

对于线程和进程，我们可以这么理解:

* 当进程只有一个线程时，可以认为进程就等于线程;
* 当进程拥有多个线程时，这些**线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的**;

这还得看线程是不是属于同一个进程:

* 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样;
* 当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在**切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据;**



#### **进程和线程、协程之间的区别**

**进程：**

* 进程是资源分配的基本单位
* 每个进程都有自己的一套独立的地址空间（虚拟内存空间）。 
* 进程间通信（IPC）需要特定的机制，如管道、信号、共享内存、消息队列等。
* 进程的创建和销毁开销相对较大，因为涉及到为进程分配独立的内存空间等资源。

**线程：**

* 线程是调度（程序执行）的基本单位。同一个进程之间的线程之间共享进程所有用的资源，除了一些必要的维护各个线程的寄存器、程序计数器、栈空间。
* 一个进程内部多个线程并发执行
* 线程间的通信可以通过读写共享变量来进行，因为它们共享相同的内存空间。
* 线程的创建和销毁开销较小，因为它们可以共享进程的资源，不需要独立的地址空间。

**协程：**

* 协程不是由操作系统管理，而是由程序自己控制。协程可以看作是用户态的轻量级线程，它们在单个线程内协作执行，而不是由操作系统内核调度。
* 拥有自己的寄存器上下文和栈
* 同一时间只能执行一个协程，而其他协程处于休眠状态，适用于对人物进行分时处理。
* 协程的调度是由程序控制的，而不是由操作系统内核控制，这使得协程的创建和销毁更加轻量级。

总结来说，进程是操作系统资源分配的单位，线程是操作系统调度的单位，而协程则是程序层面上用于提高并发性能的一种机制。进程和线程由操作系统管理，而协程通常由程序本身管理。



#### **线程占用空间：**

* **小型系统或嵌入式系统**：在资源受限的环境中，如嵌入式系统或小型操作系统，线程栈可能非常小，可能只有几百字节到几KB。
* **桌面操作系统**：
	* Windows：默认的线程栈大小通常是1MB。
	* Linux：默认的线程栈大小通常在8MB左右，但这个值可以通过编译时的配置选项进行调整。
* C/C++：程序员可以在创建线程时指定栈大小，如果没有指定，操作系统会使用默认值。
	* 程序员可以通过特定的API调用来修改特定线程的栈大小。例如，在Linux下，可以使用`pthread_attr_setstacksize()`函数来设置线程栈的大小。在Windows下，可以使用链接器选项`/STACK`或`/F`来设置程序的堆栈大小





<!-- tabs:end -->
<!-- tabs:start -->

#### **进程通信：**

* 管道：管道是无格式的字节流数据
	* 匿名管道：半双工单向通信，应用于**有血缘关系的进程**之间，创建管道时，操作系统会为管道分配两个文件描述符，一个用于读操作，另一个用于写操作。**亲缘关系的进程之间共享文件描述符**（子进程能继承父进程的文件描述符）。管道的本质是一块**内存缓冲区**，内部使用**环形队列**实现。匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。
	* 命名管道：**不具有血缘关系**的进程也能交换数据，利用FIFO文件进行数据交换，创建了一个FIFO文件，就会为其分配一块内核缓冲区，操作时不能直接操作内核缓冲区，必须通过操作FIFO文件。**FIFO严格遵守先进先出**（队列），对FIFO 的**读总是从开始处返回数据**，对它们的**写则把数据添加到末尾**。
	* 管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据
* 消息队列：**消息队列是保存在内核中的消息链表**，如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。消息队列的读取和写入的过程，都会有发生**用户态与内核态之间的消息拷贝**过程。
* 共享内存：原本虚拟内存让每个进程都有自己独立的虚拟内存空间，**共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中**，这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去。
* 信号量：**信号量**其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。信号量表示资源的数量，控制信号量的方式有两种原子操作：
	* **P 操作**：信号量减去 1，信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。
	* **V 操作**：信号量加上 1，信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；
	* 信号初始化为 `1`，就代表着是**互斥信号量**，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了**共享内存**。
	* 信号初始化为 `0`，就代表着是**同步信号量**，它可以保证进程 A 应在进程 B 之前执行


* 信号：**对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。**在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。
* socket：**跨网络与不同主机上的进程之间通信，需要 Socket 通信。**本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是**绑定一个本地文件**。



#### **虚拟内存**：

* **分配内存**：**虚拟内存可以使得进程对运行内存超过物理内存大小**，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
* **防止进程间相互影响**：由于**每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的**。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。



#### **多线程同步：**

* **锁**：加锁、解锁操作；
* **信号量**：P、V 操作
* 哲学家进餐问题



#### **锁：**

* **互斥锁：**互斥锁是一种「独占锁」当已经有一个线程加锁后，其他线程加锁则就会失败，于是就会**释放 CPU** 让给其他线程，**既然线程释放掉了 CPU，自然线程加锁的代码就会被阻塞**。**对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的**，所以，互斥锁加锁失败时，会从用户态陷入到内核态，虽然简化了使用锁的难度，但是存在一定的性能开销成本(线程的上下文切换成本)。

* **自旋锁**：自旋锁是通过 CPU 提供的 `CAS` 函数，在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程**会「忙等待」**。
	* 一般加锁的过程，包含两个步骤：
		* 第一步，查看锁的状态，如果锁是空闲的，执行第二步
		* 第二步，将锁设置为当前线程持有
		* CAS 函数就把这两个步骤合并成一条硬件级指令，形成**原子指令**

* **读写锁：**只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁，**读写锁适用于能明确区分读操作和写操作的场景**。
	* 写锁是独占锁，因为任何时刻只能有一个线程持有写锁，且加了写锁之后，**任何试图加读锁或写锁的线程都会被阻塞**，直到写者释放其写锁。
	* 读锁是共享锁，因为读锁可以被多个线程同时持有。如果线程以读模式对其加锁成功，其他线程的读锁会自动加锁成功，**读锁会阻塞写锁，但不会阻塞其他读锁**。
	* 不管优先读锁还是写锁，一直有读线程获取读锁/写锁，对方都可能会出现饿死问题，**公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队**，**，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象**。

* 悲观锁：互斥锁、自旋锁、读写锁，都是属于悲观锁，它认为**多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁**。
* 乐观锁：乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作**。
	* 我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。



#### **死锁：**

两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成**两个线程都在等待对方释放锁**，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了**死锁**。

* 互斥条件：**多个线程不能同时使用同一个资源**
* 持有并等待条件：**线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1**。
* 不可剥夺条件：**在自己使用完资源 之前不能被其他线程获取**
* 环路等待条件：线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2



#### **调度算法：**







<!-- tabs:end -->
<!-- tabs:start -->

#### **键入网址到网页显示：**

1. 解析`URL`，确定web服务器和文件名，生成发送给 `Web` 服务器的http请求信息，长长的 URL 实际上是请求服务器里的文件资源
2. DNS解析，**查询服务器域名对应的 IP 地址**。
3. 通过DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的**协议栈**。



#### **ARP协议：**

**ARP（Address Resolution Protocol，地址解析协议）** 

主要功能：将网络层的 **IP地址** 转换为数据链路层的 **MAC地址**。

- 对于主机来说，发送数据需要对数据进行封装，应用层首先要发送一个数据，传输层会将数据进行分段（数据过大时划分报文段），网络层对报文段添加首部形成IP数据报（分组），其中主要包括源主机地址与目的主机地址（根据DNS得到），到了链路层在进行封装加上MAC地址，其中除了源MAC地址，还需要目的MAC地址，那么源地址知道，**目的MAC地址**怎么获得呢（ARP协议解决）。每一台主机和路由器上都有一个**ARP高速缓存**，其中存放的是某一个IP地址及其对应MAC地址的映射。因此只需要查询ARP高速缓存就能得到目的IP地址对应的MAC地址。而当ARP高速缓存中没有目的IP地址及其对应的MAC地址，那么便需要**ARP协议。**

工作过程：

- **ARP请求**：当一台设备（如主机A）需要与另一台设备（如主机B）通信时，首先检查自身的 **ARP缓存表**。如果未找到目标IP地址对应的MAC地址，主机A会发送一个 **ARP请求广播**，询问网络中“谁的IP地址是目标IP地址”。

- **ARP响应**：网络中的所有设备都会收到ARP请求广播，但只有目标设备（主机B）会识别出请求中的IP地址与自己的IP地址匹配，并回复一个 **ARP响应**，其中包含自身的MAC地址。

- **缓存更新**：主机A收到ARP响应后，将目标IP地址与MAC地址的映射关系存储到自身的 **ARP缓存表** 中，以便后续通信时直接使用缓存中的MAC地址，而无需再次发送ARP请求。
- **数据传输**：主机A获取到目标设备的MAC地址后，即可将数据包封装成以太网帧，并通过数据链路层发送到目标设备。



#### **TCP/UDP：**

* **TCP**：
	* 是一种**面向连接**的协议，这意味着在数据传输开始之前，必须在两端建立一个连接。这个连接是通过三次握手过程建立的。
	* 提供**可靠的数据传输**服务，确保数据包按照顺序到达，如果数据包丢失或损坏，TCP会重新发送数据。
	* 数据传输是有序的，并且可以确保数据的完整性。
	* 有**流量控制**机制，如滑动窗口协议，以避免接收方被过多的数据淹没。
	* 有**拥塞控制**机制，如慢启动和拥塞避免算法，以防止网络过载。
	* 由于需要建立连接和保证数据完整性，通常速度较慢。
	* 头部开销较大，通常为20字节。
	* 适用于需要可靠数据传输的应用，如网页浏览、文件传输、邮件等。
	* 包含错误检测和纠正机制，能够处理数据传输中的错误。

* **UDP**：
	* 是一种无连接的协议，数据传输前不需要建立连接，可以直接发送数据。
	* 不保证数据包的顺序或可靠性，如果数据包丢失，UDP不会重新发送。
	* 数据传输可能是无序的，且不保证数据的完整性。
	* 由于不需要建立连接和保证数据完整性，通常速度较快。
	* 头部开销较小，通常为8字节。
	* 适用于对实时性要求高的应用，如视频会议、在线游戏、DNS查询等。
	* 不包含错误检测和纠正机制，错误处理通常由应用层完成。



#### **http状态码：**

* `1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。
* `2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。
	* 「**200 OK**」是最常见的成功状态码，表示一切正常。
	* 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同,但响应头没有 body 数据.
	* 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传,表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

* `3xx` 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。
	* 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问.
	* 「**302 Found**」表示临时重定向，说明请求的资源还在,但暂时需要用另一个 URL 来访问.

* `4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。
	* 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。
	* 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。
	* 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

* `5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。
	* 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码,,服务器发生了什么错误，我们并不知道。
	* 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
	* 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码,表示服务器自身工作正常，访问后端服务器发生了错误。
	* 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思.



#### **粘包：**

* **TCP 是面向字节流的协议**，当用户消息交给网络层通过 TCP 协议传输时，**消息可能会被操作系统分组成多个的 TCP 报文**，将这些数据发送出去就是字节流传输，没有明显的边界，会粘包。

* 用户消息通过 UDP 协议传输时，**操作系统不会对消息进行拆分**，用户消息通过 UDP 协议传输时，**操作系统不会对消息进行拆分**，也就是**每个 UDP 报文就是一个用户消息的边界**。

解决方案：

* 固定长度的消息；
* 特殊字符作为边界；
* 自定义消息结构。



#### **http与https：**

**HTTP**（超文本传输协议）是一种用于在客户端（如浏览器）与服务器之间传输超文本（如HTML）及多种类型数据的应用层**协议**。

- 超文本传输协议:
  - 超文本：可以传输除了文本之外的图像，文字，视频等
  - 传输：http是一个通过双方请求和应答的双向协议
  - 协议：对通信过程进行规范

传输过程：

- 首先http默认端口80
- 其次http的传输采用TCP传输保证数据的可靠性，而每次获取一个文件都对应一个URL，服务器可以对每个请求进行逐个处理，每处理完一个就关闭连接，但是这种短链接每次连接都要重现建立，因此在http1.1中，默认链接为长连接。
- 对于一个网页，为了保证登录时保持用户的登录状态，不至于每次都得重新登录，通过**cookie**来保持这个状态（通过在请求首部字段加上cookie信息保持登录状态，从而实现状态管理）

**HTTPS**：HTTPS（HyperText Transfer Protocol Secure，安全超文本传输协议）不是一个单独的协议，而是在HTTP的基础上加入了**SSL/TLS加密安全协议**，提供了数据加密、完整性校验和身份验证，使得数据传输更加安全。HTTPS通过加密技术保护数据的机密性，防止数据在传输过程中被窃取或篡改。

**HTTP 与 HTTPS 有哪些区别？**

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的



#### **http1.0/http1.1/http2.0/http3.0：**

HTTP 由于是工作在应用层（ `OSI` 第七层）,则它**下层可以随意变化**:HTTP/1.1 和 HTTP/2.0 传输协议使用的是 **TCP 协议**,HTTP/3.0 传输协议改用了 UDP 协议。

**http1.1/http1.0**:

* http1.1使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
* http1.1支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。



**http2.0/http1.1**

* **https：**HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

* **头部压缩：**HTTP/2 会**压缩头**（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你**消除重复的部分**。这就是所谓的 `HPACK` 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就**提高速度**了。
* **二进制格式：**HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了**二进制格式**，头信息和数据体都是二进制，并且统称为帧（frame）：**头信息帧（Headers Frame）和数据帧（Data Frame）**。
* **并发传输：**HTTP/1.1 的实现是基于请求-响应模型的，HTTP/2引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。
	* 1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位。
	* **不同 Stream 的帧是可以乱序发送的**，**针对不同的 HTTP 请求用独一无二的 Stream ID 来区分**，**接收端可以通过 Stream ID 有序组装成 HTTP 消息**，**因此可以并发不同的 Stream**。**也就是 HTTP/2 可以并行交错地发送请求和响应**。
* **服务器主动推送资源：**服务端不再是被动地响应，可以**主动**向客户端发送消息。
	* 客户端和服务器**双方都可以建立 Stream**， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。
	* 比如，客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，但在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。



**http3.0优化：**

HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是**没有解决响应的队头阻塞**，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。

HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是**一旦发生丢包，就会阻塞住所有的 HTTP 请求**，这属于 TCP 层队头阻塞。

* **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**，解决了对头阻塞问题。
*  UDP 是不可靠传输的，但基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输。





#### **SSL/TSL握手过程：**

* *ClientHello*
	* 由客户端向服务器发起*ClientHello*加密通信请求，客户端主要向服务器发送：**客户端支持的 TLS 协议版本，客户端生产的随机数，客户端支持的密码套件列表**。
*  *SeverHello*
	* 服务器收到客户端请求后，向客户端发出 *SeverHello*响应，用来：确认 TLS 协议版本，服务器生产的随机数，确认的密码套件列表，服务器的数字证书。
* *客户端回应*
	* 客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。确认完毕，**从数字证书中取出服务器的公钥**，使用它加密报文，向服务器发送：
	* 一个随机数：该随机数会被服务器公钥加密。加密通信算法改变通知（表示随后的信息都将用「会话秘钥」加密通信），客户端握手结束通知。

**服务器和客户端有了这三个随机数**，**接着就用双方协商的加密算法**，**各自生成本次通信的「会话秘钥」**。

* *服务器的最后回应*
	* 服务器收到客户端的第三个随机数（`pre-master key`）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。向客户端发送最后的信息：
	* 加密通信算法改变通知，服务器握手结束通知。



#### **SYN攻击**

SYN攻击就是攻击者短时间伪造不同 IP 地址的 `SYN` 报文，服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，但服务端发送出去的 `ACK + SYN` 报文，无法得到未知 IP 主机的 `ACK` 应答，久而久之就会**占满服务端的半连接队列（SYN队列在内核中）**，使得服务端不能为正常用户服务。

SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样**当 TCP 半连接队列满了**，**后续再在收到 SYN 报文就会丢弃**，导致客户端无法和服务端建立连接。

避免 SYN 攻击方式，可以有以下四种方法：

* 增大 TCP 半连接队列；
* 减少 SYN+ACK 重传次数；将最大重传次数减少
* 开启 net.ipv4.tcp_syncookies：使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。



#### **如果已经建立了连接，但是客户端突然出现故障了怎么办？**

**保活机制**：定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少。

#### **如果已经建立了连接，但是服务端的进程崩溃会发生什么？**

TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与。



#### **select/poll/epoll**

**select:**

* select**同时监听多个文件描述符**，将监控的操作交给内核去处理,通过一个**位掩码（bitmap）**来监控多个文件描述符的状态。位掩码中的每一位对应一个文件描述符，通过设置或清除这些位，`select` 能够监控指定文件描述符的可读、可写和异常状态





#### **TCP/UDP(Socket)通信**

网络编程主要包括：协议(TCP/IP/HTTP/HTTPS/FTP)+接口（socket）

* **socket网络编程：**
	* 预**建立连接的两个进程各自有一个socket来标识**，那么这**两个socket组成的socket pair就唯一标识一个连接**。因此可以用Socket来描述网络连接的一对一关系。**在网络通信中，套接字一定是成对出现的。**一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述管理发送缓冲区和接收缓冲区。
	* 大小端转换：**网络传输用的是大端法, 如果机器用的是小端法, 则需要进行大小端的转换.**TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。
	
* **TCP通信**：

	* 服务端
		* **创建套接字：**服务端首先创建套接字，返回一个监听文件描述符lfd，**内核会提供**与该文件描述符相对应的**读和写缓冲区**,同时还有**两个队列**, 分别是**请求连接队列（未握手）和已连接队列（已握手）.**
		* **绑定：**将套接字绑定到一个特定的IP地址和端口上
		* **监听：**服务器会调用`listen()`函数来监听这个套接字上的连接请求。`listen()`函数会将套接字从默认的主动模式（Active Mode）切换到监听模式
		* **接收连接：**:**三次握手完成后，服务器调用accept()接受连接**，**从已连接队列中获取获得一个连接, 并获得一个新的通信文件描述符cfd.**
		* **通信完成：**通信完成后，无论哪一方发起关闭连接请求，都要经历四次挥手之后，进行

	* 客户端：
		* 创建socket，得到一个通信文件描述符
		* 连接服务端---connect() 

* UDP通信：
	* 服务端
		* 创建套接字socket type=SOCK_DGRAM
		* 绑定ip和端口
		* 通信
		* 关闭套接字
	* 客户端
		* 创建套接字--socket
		* 连接ip+port，进行通信
		* 关闭套接字
* 本地socket通信
	* 在本地Socket通信中，通常**不需要配置IP地址和端口号等网络参数**，而是绑定到一个**本地文件**（通常是一个套接字文件）上进行监听，客户端通过连接这个文件来与服务端进行通信。因为它们已经位于同一台机器上。



<!-- tabs:end -->
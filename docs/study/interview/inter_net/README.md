<!-- tabs:start -->

#### **键入网址到网页显示：**

1. 解析`URL`，确定web服务器和文件名，生成发送给 `Web` 服务器的http请求信息，长长的 URL 实际上是请求服务器里的文件资源
2. DNS解析，**查询服务器域名对应的 IP 地址**。
3. 通过DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的**协议栈**。



#### **http状态码：**

* `1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。
* `2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。（200/204/206）
* `3xx` 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。
* `4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。
* `5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。



#### **粘包：**

* **TCP 是面向字节流的协议**，当用户消息交给网络层通过 TCP 协议传输时，**消息可能会被操作系统分组成多个的 TCP 报文**，将这些数据发送出去就是字节流传输，没有明显的边界，会粘包。

* 用户消息通过 UDP 协议传输时，**操作系统不会对消息进行拆分**，用户消息通过 UDP 协议传输时，**操作系统不会对消息进行拆分**，也就是**每个 UDP 报文就是一个用户消息的边界**。

解决方案：

* 固定长度的消息；
* 特殊字符作为边界；
* 自定义消息结构。



#### **GET与POST：**

* **GET 的语义是从服务器获取指定的资源**，GET 请求的参数位置一般是写在 URL 中，是安全、幂等、可被缓存的。
* **POST 的语义是根据请求负荷（报文body）对指定的资源做出处理**，POST 请求携带数据的位置一般是写在报文 body 中，POST 不安全，不幂等，（大部分实现）不可缓存。



#### **http缓存：**

* **`强制缓存：`**只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，过期则直接请求服务器。
* **`协商缓存：`**通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存.



#### **SSL/TSL握手过程：**

* *ClientHello*
	* 由客户端向服务器发起*ClientHello*加密通信请求，客户端主要向服务器发送：**客户端支持的 TLS 协议版本，客户端生产的随机数，客户端支持的密码套件列表**。
*  *SeverHello*
	* 服务器收到客户端请求后，向客户端发出 *SeverHello*响应，用来：确认 TLS 协议版本，服务器生产的随机数，确认的密码套件列表，服务器的数字证书。
* *客户端回应*
	* 客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。确认完毕，**从数字证书中取出服务器的公钥**，使用它加密报文，向服务器发送：
	* 一个随机数：该随机数会被服务器公钥加密。加密通信算法改变通知（表示随后的信息都将用「会话秘钥」加密通信），客户端握手结束通知。

**服务器和客户端有了这三个随机数**，**接着就用双方协商的加密算法**，**各自生成本次通信的「会话秘钥」**。

* *服务器的最后回应*
	* 服务器收到客户端的第三个随机数（`pre-master key`）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。向客户端发送最后的信息：
	* 加密通信算法改变通知，服务器握手结束通知。



#### **SYN攻击**

SYN攻击就是攻击者短时间伪造不同 IP 地址的 `SYN` 报文，服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，但服务端发送出去的 `ACK + SYN` 报文，无法得到未知 IP 主机的 `ACK` 应答，久而久之就会**占满服务端的半连接队列（SYN队列在内核中）**，使得服务端不能为正常用户服务。

SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样**当 TCP 半连接队列满了**，**后续再在收到 SYN 报文就会丢弃**，导致客户端无法和服务端建立连接。

避免 SYN 攻击方式，可以有以下四种方法：

* 增大 TCP 半连接队列；
* 减少 SYN+ACK 重传次数；将最大重传次数减少
* 开启 net.ipv4.tcp_syncookies：使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。



#### **如果已经建立了连接，但是客户端突然出现故障了怎么办？**

**保活机制**：定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少。

#### **如果已经建立了连接，但是服务端的进程崩溃会发生什么？**

TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与。



#### **select/poll/epoll**



#### **TCP/UDP(Socket)通信**

网络编程主要包括：协议(TCP/IP/HTTP/HTTPS/FTP)+接口（socket）

* **socket网络编程：**

	* 预**建立连接的两个进程各自有一个socket来标识**，那么这**两个socket组成的socket pair就唯一标识一个连接**。因此可以用Socket来描述网络连接的一对一关系。**在网络通信中，套接字一定是成对出现的。**一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述管理发送缓冲区和接收缓冲区。
	* 大小端转换：**网络传输用的是大端法, 如果机器用的是小端法, 则需要进行大小端的转换.**TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。

* **TCP通信**：

	* 服务端
		* **创建套接字：**服务端首先创建套接字，返回一个监听文件描述符lfd，**内核会提供**与该文件描述符相对应的**读和写缓冲区**,同时还有**两个队列**, 分别是**请求连接队列（未握手）和已连接队列（已握手）.**
		* **绑定：**将套接字绑定到一个特定的IP地址和端口上
		* **监听：**服务器会调用`listen()`函数来监听这个套接字上的连接请求。`listen()`函数会将套接字从默认的主动模式（Active Mode）切换到监听模式
		* **接收连接：**:**三次握手完成后，服务器调用accept()接受连接**，**从已连接队列中获取获得一个连接, 并获得一个新的通信文件描述符cfd.**
		* **通信完成：**通信完成后，无论哪一方发起关闭连接请求，都要经历四次挥手之后，进行

	* 客户端：
		* 创建socket，得到一个通信文件描述符
		* 连接服务端---connect() 

* UDP通信：
	* 服务端
		* 创建套接字socket type=SOCK_DGRAM
		* 绑定ip和端口
		* 通信
		* 关闭套接字
	* 客户端
		* 创建套接字--socket
		* 连接ip+port，进行通信
		* 关闭套接字
* 本地socket通信
	* 在本地Socket通信中，通常**不需要配置IP地址和端口号等网络参数**，而是绑定到一个**本地文件**（通常是一个套接字文件）上进行监听，客户端通过连接这个文件来与服务端进行通信。因为它们已经位于同一台机器上。



<!-- tabs:end -->
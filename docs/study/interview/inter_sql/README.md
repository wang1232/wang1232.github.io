MySQL 的架构共分为两层：**Server 层和存储引擎层**，**Server 层负责建立连接、分析和执行 SQL**。不同的存储引擎共用一个 Server 层。

<!-- tabs:start -->

#### **select语句的查询过程：**

客户端请求：

* 连接器：验证用户身份，给予权限。mysql是采用TCP进行数据传输的。
* 查询缓存：存在缓存则直接返回，不存在就继续执行后续操作
* 分析器：对SQL语句进行**词法分析**和**语法分析**操作，分析成功会构建语法树，
* 优化器：对执行的sql优化选择最优得执行方案方法，比如表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。
* 执行器：先看用户是否有使用权限，有才去使用这个存储引擎提供的接口，去引擎层获取数据返回给执行器。执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端。



#### **mysql一行记录的存储：**

* mysql的数据是放在磁盘里的，InnoDB使用表空间来管理存储**表和索引**的数据文件，**一张数据库表**的数据是保存在一个.ibd文件中，这个文件也称为**独占表空间文件**。
* 表空间由段（segment）、区（extent）、页（page）、行（row）组成，记录是按照行来存储的，但InnoDB 的数据是按「页」为单位来读写的，表中的**记录存储在「数据页」**里。



#### **NULL值存储：**

* MySQL不直接存储NULL值，而是使用一个特殊值来表示，在InnoDB的**Compact行格式中**，记录的真实数据部分不会存储NULL值，**使用NULL值列表来标记值为NULL的列**（**数据表的字段都定义成 NOT NULL时**就没有这个列表），按照列的顺序逆序排列二进制位，每个二进制位对应一个列，如果该列的值为NULL，则对应的二进制位为1；否则为0。




#### **行溢出：**

当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而**把剩余的数据放在「溢出页」**中，然后真实数据处用 20 字节存储指向溢出页的**地址**，从而可以找到剩余数据所在的页。



#### **索引：**

**基本索引类型：**

**（1）B+ Tree 索引**

B+ Tree 是 MySQL 默认的索引类型，适用于大多数的存储引擎，尤其是 InnoDB 和 MyISAM。它是**自平衡的多路搜索树**，其中每个叶节点都存储了数据行的指针。

* B+Tree，叶子节点才存放数据，且叶子节点是**双向链表**，利用链表指针**可以实现快速遍历**。且非叶子节点只存放索引来实现对叶子节点的查找，而且每个节点里的数据都是叶子节点的最大值，因此B+树**兼顾顺序查找和随机查找**和范围查找。
  * 叶子节点中的每个元素，都包含**指向对应记录存储地址的指针**

* mysql数据是存放在磁盘上的，B+树和B树都是节点中存放多个键值，**减少磁盘I/O操作的次数**，例如查询操作，原本的二叉树需要从根节点开始每个节点都进行比较，而每次比较都要先次**硬盘先把节点找到，在把节点从磁盘取到内存，再进行比较**，即结点是在硬盘进行的，结点内的数据操作是在内存中进行的。


**（2）哈希索引**

- 哈希索引通过计算哈希值来定位数据行的存储位置。它适用于等值查询（`=`）。哈希索引的优点是查询非常快，但缺点是不能用于范围查询。MySQL 的内存存储引擎（MEMORY）默认使用哈希索引。

**（3）全文索引**

- 全文索引主要用于处理文本数据，尤其是在处理 `TEXT` 或 `VARCHAR` 字段时。MySQL 使用一个倒排索引来存储词汇与文档的关系，全文索引支持快速的文本搜索，特别是对于大文本字段（如文章、博客等）的查找。

**（4）空间索引 (Spatial Index)**

- 空间索引用于对地理空间数据（如经纬度坐标）进行查询。它使用 R-Tree 数据结构，常用于支持空间数据类型（如 `POINT`, `LINESTRING`, `POLYGON`）的查询。

**索引的使用：**

**（1）主键索引 (Primary Key)：**

- 当创建主键时，MySQL 会自动为该字段创建一个唯一的 B+ Tree 索引。InnoDB 存储引擎会使用主键作为聚集索引，数据按照主键顺序存储在磁盘中

- **创建的主键索引和二级索引默认使用的是 B+Tree 索引**。

**（2）唯一索引 (Unique Index)**

- 唯一索引保证索引列中的数据唯一，可以为空（除主键外）。与主键索引类似，但允许列值为空。

**（3）普通索引 (Index)**

- 普通索引是最常见的索引类型，它不要求索引列中的值唯一。普通索引可以加速查询，但不保证数据唯一性。

**(4) 复合索引 (Composite Index)**

- 复合索引是指在多个列上创建的索引。复合索引可以提高针对多个列的查询效率，特别是针对多个条件的 `AND` 查询。





#### **回表：**

通过在非主键列上建立二级索引，再利用非主键列进行查找时，先利用二级索引（只存放主键值不存放真实数据）先找到主键值，再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据，**也就是说要查两个 B+Tree 才能查到数据**。

**覆盖索引**：对于频繁查询的字段，使用覆盖索引可以减少回表操作，提高查询性能。覆盖索引是一种特殊的索引，它包含了查询所需要的所有列



#### **索引记录：**

**什么时候适用索引：**

* 字段有唯一性限制的，比如商品编码
* 经常用于 `WHERE` 查询条件的字段
* 经常用于 `GROUP BY` 和 `ORDER BY` 的字段，这样在查询的时候就不需要再去做一次排序了

**什么时候不适用索引：**

* 起不到定位的字段通常是不需要创建索引的
* 字段中存在大量重复数据，不需要创建索引
* 表数据太少
* 经常更新的字段不用创建索引

**索引优化：**

* **主键索引自增：**每次**插入一条新记录，都是顺序追加操作，不需要重新移动数据**，效率很高，非自增主键插入可能会是随机数据页的某个位置，需要移动其他数据，甚至跨页进行复制数据。

* **覆盖索引优化：**一些常用的多个字段的查询，建立联合索引，避免回表。

* **主键索引非空：**

**索引失效：**

* 使用左或者左右**模糊匹配**的时候，也就是 `like %xx` 或者 `like %xx%`
* 在查询条件中**对索引列做了计算、函数、类型转换操作**
* **联合索引**要能正确使用需要遵循**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
* 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。



#### **数据页看索引：**

* InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。
* 每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。
* 数据页内包含用户记录，每个记录之间用单向链表的方式组织起来
* 为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。



#### **优化count(*)：**

* explain估算，如果你的业务对于统计个数不需要很精确
* 额外表保存计数值，插入一条记录的同时，将计数表中的计数字段 + 1，找最大值。



#### **事务特性：**

* 原子性：一个事务中的所有操作，要么全部完成，要么全部不完成。通过 undo log（回滚日志） 来保证的；
	* 每一个记录都会有隐藏字段：**最近修改事务ID和回滚指针**，回滚指针指向没修改前的记录的地址值。依靠这两个隐藏字段，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条**记录版本链表**，链表的头部是最新的旧记录，链表尾部是最早的旧记录。
	* readview创建了四个核心字段分别记录了当前活跃的事务ID等信息，系统会根据Read View中的事务ID和版本链表中的记录版本进行比较，以确定应该访问哪个版本的记录。
* 一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态；通过持久性+原子性+隔离性来保证；
* 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。通过 redo log （重做日志）来保证的；
	* 当事务对表中的数据进行修改时，这些修改首先会发生在Buffer Pool中的缓存页上，Redo Log Buffer是一个内存中的缓冲区，用于临时存储事务的修改操作（即重做日志），redo log buffer记录数据页的物理变化，当**事务提交时**，会将redo log buffer的数据页物理变化刷新到磁盘中，进行永久性的存储(**日志先行**)。如果脏页（内存和磁盘数据不一致的页）在从内存刷新到磁盘时发生错误，便可以利用redo log buffer中的数据进行恢复
	* 直接将 `buffer pool` 中的修改内容刷新到磁盘（脏页刷新）通常是随机I/O操作，因为脏页可能分布在磁盘的不同位置。而 `redo log` 是顺序写入的（**顺序IO**），因为日志是追加的，因此可以利用磁盘的顺序写入特性，速度比随机I/O快得多。

* 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，通过 MVCC（多版本并发控制） 或锁机制来保证的；

	* **读未提交（\*read uncommitted\*）**，指一个事务还没提交时，它做的变更就能被其他事务看到；

	* **读已提交（\*read committed\*）**，指一个事务提交之后，它做的变更才能被其他事务看到；在每个 select 都会生成一个新的 Read View，

	* **可重复读（\*repeatable read\*）**，启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，保证了在事务期间读到的数据都是事务启动前的记录。

	* **串行化（\*serializable\* ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；



#### **脏读、不可重复读、幻读：**

脏读：**如果一个事务「读到」了另一个「未提交事务修改过的数据」**，解决脏读现象，就要将隔离级别升级到**读已提交**以上的隔离级别

幻读：**在一个事务内多次查询某个符合查询条件的「记录数量」**，**如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。**（证明在本事务读取时，有其他事务修改提交了），**可重复读**很大程度上避免幻读现象。

不可重复读：**在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况**，就意味着发生了「不可重复读」现象。要解决不可重复读现象，就要将隔离级别升级到**可重复读以上**的隔离级别。



#### **锁：**

* **`全局锁`：**用于锁定所有表，以便进行**全局读锁定**。执行这个命令后，其他线程（包括新的连接）不能对任何表进行更新操作，直到锁被释放，全局锁主要应用于做**全库逻辑备份**。
	* 既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？
		* 如果数据库的引擎支持的事务支持**可重复读的隔离级别**，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View。

* **`表锁`**：表锁会锁定整张表，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。
	* **元数据锁**：用户在对表进行更新操作（INSERT、UPDATE、DELETE等）时会自动给表加锁，对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；对一张表做结构变更操作的时候，加的是 **MDL 写锁**；MDL 是在事务提交后才会释放，这意味着**事务执行期间，MDL 是一直持有的**。
	* **意向锁**：**意向锁的目的是为了快速判断表里是否有记录被加锁**。意向锁是在更粗粒度对象（如表）上的加锁行为，用于指示事务接下来将在更细粒度（如行）上施加什么类型的锁。事务在尝试获取锁之前可以先检查意向锁，从而**避免不必要的等待和冲突**。提高了并发性能。表锁和行锁是满足读读共享、读写互斥、写写互斥的。
	* **AUTO-INC 锁：**表里的主键通常都会设置成自增的，这是通过对主键字段声明 `AUTO_INCREMENT` 属性实现的。**在插入数据时，会加一个表级别的 AUTO-INC 锁**，然后为被 `AUTO_INCREMENT` 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。

* **`行锁`**：**行锁只有在事务中有效**。**update 和 delete 操作都会加行级锁**。**加锁的对象是索引，加锁的基本单位是 next-key lock**。

	* **记录锁：**锁住的是一条记录，其分为共享锁(S锁)和排他锁(X锁)。表中的某一行数据。记录锁确保了在锁定期间，其他事务无法对该行数据进行修改或删除。记录锁则明确依赖于索引的存在。在索引存在的情况下，记录锁能够精确地锁定目标行记录，减少锁冲突和死锁的发生。

	* **间隙锁：**锁定的不是具体的行记录，而是**两个索引之间的间隙(或者说区间)**。只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象，假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了。有效的防止幻读现象的发生。

	* **临键锁：**锁住一段**左开右闭**区间的数据。每个数据行上的非唯一索引列上都会存在一把临键锁.(除开unique/primary)





<!-- tabs:end -->


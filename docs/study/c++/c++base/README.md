# 1、内存

大多数程序的执行发生在**虚拟内存**中。当你运行一个程序时，操作系统会将程序的代码、数据以及栈和堆等内存区域加载到虚拟内存中。程序在虚拟内存中执行时，它使用的是虚拟地址，而不是物理地址。虚拟内存的管理和映射工作由操作系统负责，它通过内存管理单元（MMU）来实现虚拟地址到物理地址的映射，并且在需要时将数据从磁盘加载到内存中，或者将不再需要的数据从内存交换出去。

## 1.1、C的内存四区模型

内存四区模型主要包括代码区、全局区（或静态存储区）、栈区和堆区。以下是这四个区域的特性：

**代码区**：

* 内容：存放**函数体的二进制代码**，由操作系统进行管理。
* 特性
	* 共享性：代码区是共享的，对于频繁执行的程序，只需要在内存中有一份代码即可。
	* 只读性：代码区是只读的，以防止程序意外地修改了它的指令。
	* 初始化：在程序编译时确定，由编译器和链接器负责生成和放置

**全局区（或静态存储区）**.data/.bss/.rodata：

* 内容
	* 存放**全局变量和静态变量**。
	* 存放**常量**，包括常量和字符串常量。
* 特性
	* 生命周期：全局区内的变量**在程序编译阶段就已经分配好了内存空间并初始化**，且在程序的整个运行期间都存在。
	* 不可修改性：静态存储区内的常量一经初始化，不可修改。全局常变量存放在静态常量区，不可以通过指针或引用间接修改。
		* 全局变量和函数的释放是由操作**系统自动回收内存**
			* 如果全局变量引用了动态分配的资源，那么需要确保在程序结束前适当地释放这些资源。
		* 全局作用域中的**类对象才会调用析构进行释放**

**栈区**：

* 内容：由编译器自动分配释放，存放函数的参数值、局部变量等。
* 特性
	* 生命周期：栈区的内容从函数左括号开始，到右括号为止。函数结束后，内存自动释放回收。
	* 生长方向：栈区向下生长，数值逐渐减小。
	* 栈区的内存会自动释放
	* **函数内的局部变量**（不包括静态局部变量）以及函**数调用的参数**通常存放在栈上

**堆区**：

* 内容：由程序员分配和释放。

* 特性
	* 管理：堆区的内容由程序员自己开辟，手动释放。如果程序员不释放，程序结束时由系统回收。
	
	* 生长方向：堆区向上生长，数值逐渐增大。
	
	* 由程序员分配和释放的内存区域，通常使用 `malloc`、`calloc`、`realloc` 和 `free` 等函数在C语言中管理。在高级语言中，如Python，垃圾回收机制负责自动管理堆上的内存。
	
		![image-20240327211655823](全栈_C++.assets/image-20240327211655823.png)





堆和栈都是程序运行时才分配的空间。

## 1.2、C++内存六区模型 

每个进程都各自有独立的虚拟内存，但是**每个虚拟内存中的内核地址，其实关联的都是相同的物理内存**。

**六区：**

栈、堆、文件映射区、全局/静态存储区、常量存储区、代码区

![image-20241008151343873](全栈_C++.assets/image-20241008151343873.png)

* 代码段，包括二进制可执行代码;
* 数据段，包括已初始化的静态常量和全局变量，
* BSS 段，包括未初始化的静态变量和全局变量:
* 堆段，包括动态分配的内存，从低地址开始向上增长;
* 文件映射段，包括动态库、共享内存等，从低地址开始向上增长(跟硬件和内核版本有关口);
* 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的一般是 8 MB。当然系统也提供了参数，以便我们自定义大小;

在这6个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用C标准库的 ma11oc()或者就可以分别在堆和文件映射段动态分配内存。mmap()







## 1.2、全局变量和局部变量有什么区别

* 生命周期不一样：全局变量随着主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在了。
* 使用方式不同：通过声明后的全局变量在程序的各个部分都可以使用，存储在全局数据段，局部变量分配在堆栈区，只能在局部使用



## 1.3、内存对齐

**概念：**

实质：空间交换时间

> 一个变量占用n个字节，则该变量的起始地址必须是n的整数倍即:存放起始地址 %n=0。
>
> 如果是结构体，那么结构体的起始地址是其**最宽**数据类型成员的整数倍。

在结构体中：

* 结构体成员内存的分配顺序是按照**声明的顺序**
* 第一个成员在结构体偏移量位0的地址处
* 未特殊说明或指定，**其他成员按结构体中size最大的成员对齐**。
* **结构体大小为最大对齐数的整数倍**。



**根本原因：**

CPU需求，和CPU访问的总线宽度有关，提高CPU查询效率，浪费了空间但是提升了CPU读取速度。

例子：CPU在读取数据时，CPU位数32，总线宽度为32，4字节。那么以**整除以4**的地址开始读取数据，如果不进行内存对齐，连续存放数据。对于变量C读取时需要读取两次并进行拼接。

![image-20240327092408846](全栈_C++.assets/image-20240327092408846.png)

内存对齐后，都以4字节存储，对于变量C只需要读取一次：

![image-20240327092644151](全栈_C++.assets/image-20240327092644151.png)





**新特性：**

C++11引入了新特性：

* alignas：(指定结构体的对齐方式)
	* alignas指定的(结构体)对齐方式必须≥数据成员类型，小于自然对齐的最小单位，则被忽略。
	* 对于单字节的对齐方式，应使用#pragma pack(push,1)或_attribute_((packed))
* alignof：(计算类型的对齐方式)

```c++
struct alignas(4) info{
	unit8_t a;
	unit16_t b;
    alignas(8) char d;
    alignas(double) int e;
	unit8_t c;
};
```

![image-20240327105832488](全栈_C++.assets/image-20240327105832488.png)

![image-20240327105908336](全栈_C++.assets/image-20240327105908336.png)



# 2、指针与引用

## **2.1 、指针和引用的区别**

指针：

* **定义**：指针是存储变量地址的变量。通过指针，我们可以直接访问和操作内存中的数据。指针变量本身存储的是一个地址值，该地址指向另一个变量的内存位置。
* **操作**：指针可以进行多种操作，包括赋值（指向不同的地址）、算术运算（如指针递增以访问数组中的下一个元素）、比较（比较两个指针是否指向同一位置）等。
* **特点**：指针具有灵活性，但也带来了复杂性，因为不当的指针操作可能会导致内存泄漏、野指针（dangling pointer）等问题。

引用：

* **定义**：引用是变量的别名。一旦引用被初始化为某个变量的别名，它就不能再被改变为另一个变量的别名（即引用必须被初始化，且一旦初始化后就不能再被重新绑定到另一个对象）。
* **操作**：对引用的操作就像是对它所引用的变量的直接操作一样。引用通常用于函数参数传递和返回值，以避免不必要的拷贝和提高性能。
* **特点**：引用提供了一种更安全、更简洁的方式来访问和操作变量，因为它在语法上表现得就像是直接访问变量本身一样。然而，引用也有限制，比如它必须在声明时被初始化，并且之后不能改变其绑定的对象。

**指针和引用的主要区别**：

1. **初始化**：指针在声明时不必初始化（尽管这是一个好习惯），而引用必须在声明时被初始化。
2. **空值**：指针可以被设置为`nullptr`（或在C中为`NULL`），表示它不指向任何对象；而引用必须始终指向某个对象，不能为空。
3. **灵活性**：指针比引用更灵活，可以进行算术运算、比较等操作；而引用一旦绑定到某个对象后，就不能改变其指向。
4. **安全性**：引用在安全性上通常优于指针，因为它避免了空指针解引用、野指针等常见错误。
5. 存储：sizeof指针得到的是指针的大小，sizeof引用得到的是引所指向变量的大小

## **2.2、传递参数时，什么时候使用指针，什么时候使用引用。**

* 返回函数内局部变量的内存的时候用**指针**，使用指针需要开辟内存，用完要记得释放指针，不然会内存泄漏。
* **类**对象作为参数传递使用**引用**。
* 对栈空间大小比较敏感（递归）时使用**引用**，引用作为别名传递时不需要创建临时变量，开销更小。





## **2.3、指针类型的区分**

```c++
int *p[10]; //指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
int (*p)[10]; //数组指针，强调指针，只有一个变量是指针类型，指向的是一个int类型，大小为10的数组.
int *p(int) //函数声明，函数名为p，参数是int类型，返回值为int*类型。
int (*p)(int) //函数指针，强调是指针，指针指向的函数具有int类型参数，返回值是int型。
```



## 2.4、指针和函数

**返回的值是指针的函数：**

```c++
int *func(){
	int a = 10;
	int *p = &a;
	return p;
}
```

**指向函数的指针**:函数指针

* 函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是类型的一部分。
* 一个函数名就是一个指针，其指向函数的代码
	* 函数地址就是该函数的进入点，也就是调用函数的地址
		* 函数的调用：可以通过函数名调用，可以通过指向函数的指针
		* 函数指针还可以将函数作为变元传递给其他函数

```c++
int (*p)(const int&,const int&) = nullptr; //()的优先级大于*
int func(const int &a,const int &b){
	int c = a+b;
	return c;
}
p = func; //p指向func
p = &func;
int result = p(10,20); //30

#include <stdio.h>
// 带有函数指针参数的函数
int applyOperation(int (*p)(int), int value) { //函数指针作为变元传递给函数
    int result = p(value);
    return result;
}

// 一个简单的函数，对输入值进行平方操作
int square(int x) {
    return x * x;
}
// 另一个简单的函数，对输入值进行立方操作
int cube(int x) {
    return x * x * x;
}

int main(){
    int inputValue = 5;
    applyOperation(square, inputValue); //将函数作为参数给另一个函数
    applyOperation(cube, inputValue);
    return 0;
}
```

* 函数指针的存在意义：
	* 函数也有地址，我们希望在**同一个函数中通过使用相同的形参在不同的时间使用产生不同的效果。**





## **2.5、指针常量和常量指针**

**指针常量**：**是一个指针，指向的是只读变量**（const int *p），无法通过指针来修改该常量的值，但是可以通过其他途径。

**常量指针**：指针本身是一个对象，而引用不是，因此能被定为常量，一个不能更改其指向的指针。**指针是个常量，必须初始化**，初始化完成后，便不能更改(即存放在指针上的地址无法更改)（int *const p）



## **2.6、数组名和指针**

* 二者均可通过增减偏移量来访问数组中的元素

* 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减操作。
* 当数组名当作形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但是sizeof运算符不能再得到原数组的大小了。



## 2.7、野指针和悬空指针

都是指向无效内存区域（不可控不安全的区域）的指针，访问行为会导致未定义行为。

**野指针**：

* 指的是未初始化的指针
	* 产生原因：指针未及时初始化
	* 解决方法：置空或者及时初始化

**悬空指针**：

* 指针最初指向的内存已经被释放了的一种指针；
	* 产生原因：指针free或者delete之后没有及时置空
		* 一个指针变量，其存储的地址曾经是某个动态分配的内存块的地址，内存已经被释放了（`free`、`delete`），而指针变量本身的值（即它所存储的地址）并没有被设置为`nullptr`或指向另一个有效的内存地址。
	* 解决方法：释放操作后立马置空，使用**智能指针**



## 2.8、形参与实参的区别

**形参的调用过程：**

1. 从栈空间分配空间
2. 从实参的存储空间复制值到形参栈空间
3. 进行运算



**形参和实参的区别：**

* 形参变量只有**在被调用时才分配内存单元**，在未调用时都是没有分配内存空间的，在**调用结束后，形参弹出栈空间，即刻释放所分配的内存单元**，因此**形参只有在函数内部才有效**，函数调用结束后则不能再使用该形参变量。
* 实参无论是那种类型的量，在进行函数调用时必须有确定的值，才能传递给形参，在传递时会产生一个临时变量。
* 形参与实参在数量、类型、顺序上必须完全一致。
* 函数调用时，只能将实参传递给形参，不能将形参的值反向的传递给形参，因此函数调用只会修改形参的值，不会修改实参的。



## 2.9、值传递、引用传递、指针传递的区别

* **值传递**：
	
	* 有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象，或者是大的结构体对象，将消耗一定的时间和空间。
	* 为了将实际参数（实参）传递给函数，会创建一个或多个**临时对象来存储实参的值**。这些临时对象就是实参的副本，也就是形参。
	* 在值传递中，每个实参的副本都会被创建在函数调用的**栈帧**中，作为形参。这个副本是实参的一个独立拷贝，它在函数执行期间存在，并且其生命周期与函数调用的生命周期相同。
	* 在**函数内部对形参**（即**实参的副**本）的任何修改都**不会影响到原始的实参**。
	
	总结：
	
	​	在值传递中，函数参数是被调用时传递的值的副本。也就是说，在调用函数时，会将实参的值复制一份传递给形参，函数内部操作的是这个副本。**形参是实参的拷贝**。
	
* **指针传递**：
	
	* 也有一个形参向函数所属的栈**拷贝**数据的过程，但是拷贝的数据是一个固定为4字节的**地址**（拷贝的是实参的地址，指向的是实参）
	* **指针传递本质和值传递一样**，都是传递数值的过程，唯一的区别是一个传的具体数值给寄存器，一个**传的数值的地址给寄存器**。
		* 寄存器是主调函数向被调函数输入参数的载体
	
	总结：
	
	​	在指针传递中，**形参也是实参的拷贝**，**只不过拷贝的是地址，这个地址指向了实参在内存中的位置，函数内部通过指针变量间接访问和修改实参所指向的数据**。函数参数是指向实参的指针。指针传递本质和值传递一样，因此也要给形参分配存储单元，也就是说，在调用函数时，会将实参的地址传递给形参，函数内部通过指针来访问实参的值。
	
* **引用传递：**
	* 也有一个形参向函数所属的栈**拷贝**数据的过程，但其是针对地址的，相当于为该数据所在地址起了一个别名（地址）。
	* 被调函数的形参也作为局部变量在栈中**开辟了内存空间**，但是这是存放的是由主调函数放进来的实参变量的地址。
	
	总结：
	
	​	   在引用传递中，**形参并不是实参的拷贝**，而是实参的一个**别名**或**引用**。这意味着**形参和实参在底层都指向同一块内存地址**，因此对形参的任何修改都会直接影响到实参。使用引用传递时，编译器会生成代码，使得函数内部的引用形参能够直接访问到实参的内存地址。在底层，这通常是通过**将实参的地址传递给一个隐藏的指针来实现的**，但这个指针对于程序员来说是不可见的。
	
	
	
	**引用传递和指针传递的不同**
	
	* 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个**间接寻址**的方式操作主调函数中的相关变量。
	* 从编译的角度讲，程序在编译时分别将指针和引用添加到符号表中，符号表上记录的是变量名及变量所对应地址。
		* 指针变量在符号表上对应的地址值位指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，但是地址相同）
		* 在符号表生成之后，指针的值可以改变其指向（指针变量的值可以修改），而引用对象则不能修改。
	
* 效率上讲：指针传递和引用传递比值传递效率高，因为只需要复制指针和地址。值传递有生成副本的时间和空间消耗

* 当函数有多个返回值时，不能用普通的return的方式实现，需要通过地址/指针传递

* 数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。

**案例：**

```c++
void func1()
{
     int *pa = NULL;
     func2(pa); /// 函数返回后pa仍然是空指针，错误点在于这里是值传递，传递pa并不能影响到*pa，传递的是pa的一个拷贝，
    			/// 且由于 pa 存储的是 NULL，这个地址值（即 NULL）本身并没有指向任何有效的内存区域。
     delete pa; /// pa仍然是空指针，pb申请的空间并没有被delete掉
}
 
void func2(int *pb)
//void func2(int *&pb)  //修改使用引用传递即可
{
    pb = new int(5); /// pb重新申请了堆空间，错误点在于没有释放
    				///在 func2 内部对 pb 所做的任何修改，且都不会影响到 func1 中的 pa
}
```



# 3、堆和栈

## **3.1、c++中的内存区域**

**栈：**由编译器在需要的时候分配，在不需要的时候自动清除的变量存储区。里面通常是**局部变量，函数参数和返回值**等。

**堆：**由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

**自由存储区：**通过new操作符进行内存申请，该内存即为自由存储区。

**全局/静态存储区**：全局变量和静态变量被分配到同一块内存中，在以前的c语言中。全局变量又分为初始化的和未初始化的，在c++里面没有这个区分了，他们共同占用同一块内存。

**常量存储区**：这是一块比较特殊的存储区，里面存放的是常量，不允许修改。



## **3.2、 程序运行时的内存区域**

C++ 程序在运行时也会按照不同的功能划分不同的段，C++ 程序使用的内存分区一般包括：栈、堆、全局/静态存储区、常量存储区、代码区。
栈：目前绝大部分 CPU 体系都是基于栈来运行程序，栈中主要存放函数的**局部变量、函数参数、返回地址**等，栈空间一般由操作系统进行默认分配或者程序指定分配，栈空间在进程生存周期一直都存在，当进程退出时，操作系统才会对栈空间进行回收。

堆：动态申请的内存空间，就是由 malloc 函数或者 new 函数分配的内存块，由程序控制它的分配和释放，可以在程序运行周期内随时进行申请和释放，如果进程结束后还没有释放，操作系统会自动回收。我们可以利用

全局区/静态存储区：主要为 .bss 段和 .data 段，存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。

常量存储区：.rodata 段，存放的是常量，不允许修改，程序运行结束自动释放。

代码区：.text 段，存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。

![image-20240318112010618](全栈_C++.assets/image-20240318112010618.png)





## **3.3、堆和栈在内存管理的区别**

堆（Heap）和栈（Stack）是计算机内存中两种不同的区域，用于存储程序运行时的数据。它们都位于**虚拟内存**中，但在物理内存上的分配和管理方式不同。

而对于代码来说，当考虑到变量的生命周期时，堆与栈的区别就体现出来了。这个变量的生命周期到底是局限在函数内部，还是超越函数，而在栈帧中对局部变量的管理也只是移动指针（寄存器）即可。

* **管理方式不同**: **栈**是由编译器自动申请和释放空间，**堆**是需要程序员手动申请和释放;

	* 栈和堆同时动态的，栈空间存储局部变量和函数调用的信息，每个函数调用的开始和结束都会导致栈空间的减少。

* **空间大小不同**: <u>**栈**的空间是有限的</u>，是一片连续的内存区域，操作系统预设好的，在32位平台下，VC6下默认为1M，**堆**并不连续，受限于计算机系统中的有效的虚拟内存，最大可以到4G;

* **能否产生碎片**: **栈**和数据结构中的栈原理相同，在弹出一个元素之前，上一个已经弹出了，不会产生碎片，而程序员如果不停地调用new,delete会造成很多内存碎片;

* **生长方向不同**: <u>**堆**开口向上</u>，生长方向是向上的，也就是向着内存地址增加的方向，刚好相反,<u>**栈**开口向下</u>，向着内存减小的方向生长，上面为高地址，向下为低地址。同时栈的内存存放方向是高位字节放在高地址，低位字节放在低地址。

* **分配方式不同**: **堆**都是动态分配的，没有静态分配的堆，栈有静态分配和动态分配。**栈**的静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。

* **分配效率不同: **<u>**栈**的效率比堆高很多</u>。栈是机器系统提供的数据结构，计算机在底层提供栈的支持，分配专门的寄存器来存放栈的地址，压栈出栈都有相应的指令，因此比较快。**堆**是由库函数提供的，机制很复杂，库的数会按照一定的算法进行搜索内存，并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此比较慢。

	**堆通常的使用场景**

	* **创建大型对象或数组**：当对象或数组的大小在栈上分配可能会导致栈溢出时，可以使用堆内存。
	* **动态数据结构**：如链表、树和图等，它们的大小在程序运行时可能会变化，因此通常使用堆内存来存储它们的节点。
	* **对象生命周期管理**：当需要控制对象的生命周期，使其超过创建它的作用域时，可以使用堆内存。



## 3.4、栈（方法调用的原理）

* **栈帧**：为单个过程分配的把部分栈成为栈帧（也就是函数{}包含的部分）；
	
	* 栈帧可以认为是程序栈的一段，其有两个端点，一个表示起始地址，开始地址指针寄存器ebp，一个标识结束地址，结束地址指针寄存器esp。
	* **ebp寄存器**：基址指针寄存器（帧指针寄存器），它内存放一个指针，**该指针指向系统栈最上面一个栈帧的底部**。在函数调用时，ebp**被用来保存当前栈帧的基址**，从而可以方便地访问函数的局部变量和参数。通过ebp，程序可以在函数调用和返回过程中维护正确的执行上下文。
	* **esp寄存器**：栈指针寄存器，用于指向当前整个栈的栈顶（下一个压入栈的活动记录的顶部）。它内存放一个指针，**该指针永远指向系统栈最上面一个栈帧的栈顶**。当数据被压入栈时，esp的值会减小(栈是向下生长的)；当数据从栈中弹出时，esp的值会增大。通过esp，程序可以控制和管理栈上的数据。
	
* **栈是由一系列栈帧（Stack Frame）构成的**。栈帧是编译器用来实现函数调用的一种数据结构，它保存了函数调用期间的局部变量、**返回地址**、操作数栈等信息。**每当一个函数被调用时，就会在栈上创建一个新的栈帧**，用来保存该函数执行时的状态。当函数执行完毕后，对应的栈帧就会被销毁，释放其占用的内存空间。因此，栈的结构就是由这些栈帧构成的，每个栈帧都对应着一次函数调用。

	* 返回地址：被调用函数执行结束后跳回的地方。
	* **call指令**：每一个函数都保存在代码段中，当一个函数调用另一个函数时，会调用**call**指令，call指令会调转到被调用函数的入口地址处开始执行，即会将下一条指令的地址存入内存。
	* **ret指令**：而每一个函数最后又有一个**ret**指令，负责在函数结束后跳回到调用处继续执行后。
	* **rip寄存器**：
		* `rip`（或称为`RIP`，具体取决于汇编器的语法和文档）是程序计数器寄存器，它始终存储着CPU当前正在执行的指令的地址。因此，无论是否执行`call`指令或发生函数调用，`rip`都会在使用中。
		* 每当CPU执行一条指令时，它都会从`rip`寄存器中读取下一条要执行的指令的地址。在执行过程中，`rip`的值会自动递增以指向下一条指令。即使在函数内部执行指令时，`rip`也在不断地更新，以反映当前执行的指令位置。
		* 当执行`call`指令时，`rip`的值会被临时保存（通常压入堆栈），以便在函数返回时能够恢复执行点。然后，`rip`的值会被设置为被调用函数的起始地址，从而开始执行该函数。

	* 栈有bp栈基和sp栈指针

	![image-20240411091711941](全栈_C++.assets/image-20240411091711941.png)

* **栈的扩展**：栈帧的大小在编译期间确定，当函数需要的空间不够用时，编译器可以在函数头部插入检测代码，如果需要”栈增长“，需要另外分配另外一段较大栈空间，然后将旧空间的值复制过来。最后释放旧的栈空间。

* 一个栈帧对应一个过程，每一个栈指针+4的位置存储函数返回的地址，每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延申，因此如果将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果将栈的指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。

![image-20240411095831489](全栈_C++.assets/image-20240411095831489.png)

如图：

* 首先是main函数的栈帧，esp标识栈顶的内存地址（在系统最上面一个栈的顶部），edp用来标识main函数的栈帧基地址（在系统最上面一个栈的底部）
	* **sub指令**：可以从一个寄存器或内存位置中减去另一个值，并将结果存储在指定的寄存器或内存位置中
* 其次是func函数的栈帧，esp和edp的位置如同main函数，一个在栈帧顶一个在栈帧底。

**指令执行过程：**

* 首先将寄存器edp的初始值，压入栈顶（即保存edp的值），esp自动向上移动一格（可以保证在最后调用完成后返回时能回到最初的edp状态）。

* 其次，通过mov指令，将esp的值给edp。现在edp指向马上要调用的func的函数的基地址。

* 然后，通过sub指令，将esp提升8个水位线，用来保存func函数的调用信息，给两个临时变量分配堆栈内存，func()函数的栈帧设置完成。

	![image-20240411102624874](全栈_C++.assets/image-20240411102624874.png)

* 然后通过mov指令对ab进行赋值

* 当函数返回时，为了恢复main函数的栈帧，通过mov指令，先将edp的内容给esp，降低esp水位线，保证esp与edp持平，然后通过pop指令，将事先压入栈顶的edp值返换给寄存器edp，即将edp回到初始main函数的栈底，而这里由于0x80000020（edp刚开始的基地址）被pop，因此esp也下降指向main函数栈帧的顶部。

![image-20240411101849740](全栈_C++.assets/image-20240411101849740.png)



**注意：**

* 虽然函数调用的相关信息（如堆栈帧）保存在栈上，但函数本身的代码（即函数体）并不直接存储在栈上。**函数体通常存储在程序的代码段**或文本段中，这是程序的只读部分，而栈用于存储程序运行时的动态数据。
* 函数调用时，rip寄存器、ebp寄存器和esp寄存器是协同工作的。rip寄存器负责指令的执行和跳转，ebp寄存器帮助访问函数的局部变量和参数，而esp寄存器则管理着数据的压入和弹出操作。它们共同确保函数调用的正确执行和程序的流畅运行。

**总结：**

* 操作系统会为每个任务分配：一段内存，当作任务堆栈，cpu提供两个寄存器esp和edp用来标识当前函数对堆栈的使用情况，随着函数的调用，函数的栈帧会逐层堆叠，互不重合，当函数逐层返回，栈帧会被清理，但是内存不会释放。
* 正括号（{）用来保护上层主调函数的栈帧，并设置被调函数的栈帧，反括号用来放弃被调函数的栈帧，同时恢复主调函数的栈帧，这样被调函数执行完后，主调函数就能继续执行
* edp寄存器保存当前函数的栈帧基地址，配合一定的偏移，就可以读写函数体内的临时变量，如果一个变量通过edp寄存器间接访问，那么这个变量往往是临时变量
* 不同编译器对栈帧的实现方法不同，但思路一样
* rdp和rsp是x86-64位寄存器，edp和esp是x86-32位寄存器，两者功能类似，只是在不同的系统中。



## 3.5、C++函数的压栈过程

### 3.5.1、函数的压栈过程

```c++
int f(int n){
	cout << n << endl;
	return n;
}
void func(int param1,int param2){
	int var1 = param1;
	int var2 = param2;
	printf("var1 = %d,var2= %d",f(var1),f(var2));
}
int main(int argc,char *argv[]){
	func(1,2);
    return 0;    
}
//输出结果
printf: 2 1 var1=1,var2=2 
cout: var1=1,var2=2 1 2 //cout是按照正常顺序执行，有严格的调用顺序
```

* 当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数（从左往右）、main函数中的变量、进行依次压栈；

	* 调用者函数使用call指令调用被调函数，并把call指令的下一条指令的地址当成返回地址压入栈中。
	* 在被调函数中，被调函数会先保存调用者函数的栈低地址（push edp)，然后再保存调用者函数的栈顶地址。
		* 即：move edp esp

	* 在被调函数中，从edp的位置开始存放被调函数的局部变量和临时变量，并且将这些变量的地址按照定义时的顺序依次减小。

* 当main函数开始调用func()函数时，编译器会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的**参数从左往右**、func()定义变量依次压栈。

	* c中，对函数参数的扫描是从右往左**，c++中函数参数是从左往右入栈的**
	
* 当func()调用f()时，编译器将将func的运行状态进行压栈，再将f()函数的返回地址、函数的参数从左往右、f()定义变量依次压栈。

* 根据输出结果能看到，f(var1),f(var2)依次入栈，先执行f(var2)。再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。

	

**函数的调用过程：**

* 从栈空间分配存储空间
* 从实参的存储空间复制值到形参栈空间
* 进行运算

### **3.5.2、临时变量作为返回值时的处理过程**

临时变量，在函数调用过程中是被压到程序进程的栈中，当函数退出时，临时变量出栈，即临时变量被销毁，但是临时变量占用的内存空间没有被清空，还可以被分配给其他变量。

* 函数调用结束后，**返回值被临时存储到寄存器中**，并没有放到堆和栈中，当退出函数的时候，临时变量可能被销毁，但是返回值被放到寄存器中与临时变量的生命周期没有关系了。
* 需要返回值的话，**一般赋值操作可以获取**                                                                                   





# 4、new与delete

## 4.1、C++中的几种new

典型的new有三种：plain new、northrow new和placement new

### 1、**plain new**：

* 也就是普通的new，plain_new在空间分配失败的情况下，抛出std::bad_alloc而不是NULL。
	* **bad_alloc是C++标准库中的一个异常类，用于表示内存分配失败的情况**。

```c++
int main(){
	try{
		char *p = new char[100];
		delete p;
	}
	catch (const bad_alloc &ex){
		cout << ex.what() << endl;  //bad allocation
	}
	return 0;
}
```

底层实现：

```c++
void *operator new(std::size_t) throw(std::bad_alloc);
void delete delete(void *) throw;
```

### **2、nothrow new:**

**内存空间申请失败时**不会返回异常，而是**返回nullptr**

```c++
int *p = new(std::nothrow) int;
if(p == nullptr)
```

底层实现：

```c++
 void *operator new(std::size_t,const std::nothrow_t&) throw
 void operator delete(void *) throw();
```

### 3、**placement new（定位new）：**

定位new允许在一块已经分配成功的内存上**重新构造对象或对象数组**，其**不分配内存**，而是接收一个指针，在指针指向的位置构造对象。

* palcement new的主要用途时**反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组**。
* palacement new**构造起来的对象数组，必须显式的调用其析构函数进行销毁**，**且不能使用delete**。
	* palacement new构造的对象或数组不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者在之后释放内存时出错。

```c++
class person{
public:
	int m_age;
	string m_name;
public:
	person(){
		this->m_age = 10;
		this->m_name = "wang";
	}
	~person(){}
}

person *p = new(nothrow) person;
person *q = new(p) person;  //定位new，只要p所指向的空间足够person创建就不会失败

q->person::~person(); //显示调用析构去释放，不能使用delete
delete p;
p = nullprt;
```

底层实现：

```c++
void *operator new(size_t,void*);
void operator delete(void*,void*);
person *q = new(p) person();
	void *mem = operator new(sizeof(person),p);
	person *q = (person *)mem;
	q->person::person();
```





## 4.2、new的重载

```c++
class Airplane{
public:
    Airplane *next;
private:
	static const int BLOCK_SIZE;
	static Airplane *headOfFreelist;  //指向Airplane类型对象的指针，headOfFreelist是变量名
}
Airplane *Airplane::headofFreelist;  //类外初始化.默认为0
const int Airplane::BLOCK_SIZE = 512;

void *Airplane::operator new(size_t size){
    Airplane *p = headofFreelist;  //p = 0
    if(p){
        headofFreelist = p->next;
    }
    else{
        Airplane *newBlock = static_cast<Airplane *>(::operator new(BLOCK_SIZE *sizeof(Airplane)));
        //利用全局的operator new申请了BLOCK_SIZE*sizeof(Airplane)大小的内存空间，并强转给临时对象newBlock
        for(int i = 1;i<BLOCK_SIZE-1;i++){
			newBlock[i].next = &newBlock[i+1];
        }
        newBlock[BLOCK_SIZE-1].next = 0;
        p = newBlock;
      headofFreelist = &newBlock[1];  
    }
    return p;
}
```

![image-20240404110223489](全栈_C++.assets/image-20240404110223489.png)









## **4.3、new/delete和malloc/free的区别**

**相同点：**

* 都是为了申请一片可以自由管理的内存空间，用于内存的动态申请和释放。

**不同点：**

* new/delete是c++运算符，可以重载，malloc/free是c/c++语言标准库函数；

* new分配的位置是在自由存储区，malloc分配的位置是在堆中；

* new**自动计算要分配的空间大小**，malloc需要**手工计算**；

* new是类型安全的（返回对象类型的指针需要和对象类型一致），malloc不是。malloc的返回值是void*，其会自动进行类型转化，但是一般在写的时候也会根据类型进行强转。

* new调用operator new的标准库函数进行内存空间的分配**并调用相关对象的构造函数**。

	delete对指针所指向的对象**运行适当的析构函数**，然后通过operator delete标准库函数释放该对象的内存。

* new封装了malloc，直接free不会报错，但这只是释放内存，不会析构对象。

* malloc和free返回的是void*指针类型，new和delete返回的是具体类型指针。

*  new可以重载，new底层是operator new与construct（构造），可以自己重写，malloc由系统提供不能重载。

* new申请内存分配失败会返回bad_alloc异常，malloc返回NULL；

![image-20240327143225782](全栈_C++.assets/image-20240327143225782.png)

```c++
person *p = new person; //本质上两种写法没有区别，都是再对上分配一个person对象
person *p = new person(); //更清晰地表明你正在调用构造函数
```



## **4.4、new与delete的实现过程**

**new：**

* **对于简单数据类型**：

	* 直接调用**operator new**运算符分配内存

	* new [] 数组类型，先计算好大小再分配内存

```c++
int *p = new int(5);
int *p = new int[5];
test *p  = new test();
	void * mem = operator new(sizeof(test));  //申请内存
	test *p = (test *) mem; //指针转化
	p->test::test(); //调用构造函数
```

* **对于复杂数据类型**：

	* **首先**调用operator new运算符，**分配**对象类型的**内存**，来保存对象，

	* **其次**，运行该类型的**构造函数**，用指定初始化构造对象，

	* 最后**返回**执行新分配并构造后的对象的**指针**。
		* 对于复杂类中的new [] 数组空间申请，会将指针**p的前四个字节写入数组大小n**，然后调用n次构造函数，new会额外存储数组大小。
		* `new[]` 为数组中的**每个对象调用构造函数**，而 `delete[]` 则为数组中的**每个对象调用析构函数**。

**delete：**

* **对于简单数据类型：**
	* **默认调用free函数**，直接释放内存

	```
	p->~test();
	operator delete(P);
	```
	
* **对于复杂数据类型**：

	* 首**先**对指针指向的对象运行适当的**析构**函数，然**后**通过调用名为operator delete运算符**释放**该对象的**内存**。
		* 因此可以看出析构函数不会释放内存，delete才会释放内存，析构函数只是包含了调用这些操作符的代码。
	* 如果指针p指向new[]分配的内存，会有4个字节存储数组大小，实际分配内存地址为[p-4]，而delete实际释放的也就是p-4指向的内存。因此new与delete对应，new[]与delete[]对应，这也是**delete能知道释放内存大小的原因**。
	
	```c++
	test *t = new test[3]{test(1),test(2),test(3)};
	delete [] t;  //正常的话会调用三次构造与析构，顺序仍然是先构造的后析构
	delete t; //报错，只会执行一次析构，并且返回异常
	```
	
	

## 4.5、malloc/free的实现原理

molloc/free底层是通过**brk、mmap**、munmap实现的，分配的**虚拟内存**，

* 如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存的，这样就不会占用物理内存了.
* 只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。

molloc申请内存的时候，有两种申请方式：

* 方式一：通过**brk()系统调用从堆分配内存**，free时**并不会将内存还给操作系统，而是放入malloc的缓存池中**，当进程再次申请同样大小的字节的内存就可以直接复用。除非进程终止了
* 方式二：通过**mmap()系统调用在文件映射区域分配内存**，free时内存会直接归还给操作系统，得到真正的释放。

方式一实现的方式很简单，就是**通过 brk()函数将「堆顶」指针向高地址移动，获得新的内存空间**。如下
图:

![image-20241008145328485](全栈_C++.assets/image-20241008145328485.png)



方式二通过 mmap()系统中调用**「私有匿名映射」**的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。如下图:

![image-20241008145434320](全栈_C++.assets/image-20241008145434320.png)

malloc() 源码里默认定义了一个**阈值**:

* 如果用户分配的内存小于 128 KB，则通过 brk() 申请内存.
* 如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存;

**注意，**不同的 glibc 版本定义的阈值也是不同的。



**相关问题：**

为什么不全使用mmap或者brk来分配内存？

mmap缺点：

* 因为向操作系统申请内存，是要通过系统调用的，执行系统调用是要进入内核态的，然后在回到用户态运行态的切换会耗费不少时间。所以，申请内存的操作应该避免频繁的系统调用，如果都用 mmap 来分配内存，等于每次都要执行系统调用。
* 另外，因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次 mmap 分配的虚拟地址都是缺页状态的，然后在第一次访问该虚拟地址的时候，就会触发缺页中断。

也就是说，**频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断(在第一次访问虚拟地址后)，这样会导致 CPU 消耗较大**。

brk缺点：如果释放时释放了10k的内存，将该内存加入到malloc的内存池，但是后面申请的时候，又每次都大于10K导致这块内存一直无法使用，导致内存泄漏。



**malloc 的实现原理**

1. 内存管理策略：
	* **显式链表**：一些实现使用链表来管理空闲内存块。每个内存块都包含有关其大小、是否空闲以及指向下一个内存块的指针的信息。
	* **隐式链表**（如使用边界标记法）：在内存块的开始或结束处放置额外的信息（如大小、状态等），而不需要单独的指针字段。
	* **位图**：用于跟踪哪些内存块是空闲的，这通常用于较小的内存分配器。
	* **分离适配法**：将内存分成多个大小不同的链表，每个链表包含特定大小的内存块。
2. 请求处理：
	* 当 `malloc` 被调用时，它首先计算请求的内存大小（包括可能的额外开销，如用于跟踪内存块状态的信息）。
	* 然后，`malloc` 遍历空闲内存块列表（或采用其他策略），查找足够大的空闲块。
	* 如果找到足够的空闲块，`malloc` 会将其从空闲列表中移除，并返回指向该块的指针（可能需要调整返回的指针以跳过用于内部管理的额外空间）。
	* 如果没有找到足够的空闲块，`malloc` 可能会尝试合并一些小的空闲块，或者调用更底层的内存分配函数（如 `brk` 或 `mmap` 在 Unix-like 系统中）来请求更多的内存。
3. 内存对齐：
	* 分配的内存块通常会根据目标平台的内存对齐要求进行对齐，以确保访问速度并避免硬件异常。

**free 的实现原理**

1. 释放内存块：
	* 当 `free` 被调用时，它首先验证传入的指针是否指向一个有效的、之前由 `malloc` 或相关函数分配的内存块。
	* 然后，`free` 将该内存块标记为空闲，并将其重新添加到空闲内存块列表中（或采用其他方式管理）。
2. 合并空闲块（可选）：
	* 在某些实现中，`free` 会检查相邻的内存块是否也是空闲的，并尝试将它们合并成一个更大的空闲块，以减少内存碎片。
3. 内存归还给操作系统（可选）：
	* 如果某个内存区域（如通过 `mmap` 分配的大块内存）变得完全空闲，并且满足某些条件（如大小超过某个阈值），则可能会将其归还给操作系统。

* molloc申请的内存空间不能通过delete来进行释放，因为molloc需要指定释放内存的大小，不适用于动态空间的内存释放。



## **4.6、free内存回收**

malloc函数要么返回一个指向分配的内存块的指针，要么在分配失败时返回NULL。

而malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节，多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小，因此，**free() 函数只传入一个内存地址，也能知道要释放多大的内存**。

​		**堆的内存管理机制**：系统中有一个记录空闲内存地址的**链表**，系统收到程序申请时，遍历该链表，寻找一个大于申请空间的堆结点，删除链表中的该结点，并将该结点空间分配给程序(new也是遵循这样的规则)。

​		被free回收的内存首先被**ptmalloc**使用双链表保存起来（类似快表），当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回，这样可以避免频繁的系统调用，占用过多的系统资源。同时ptmalloc会对小内存块进行合并，避免过多的内存碎片。





## 4.7、delete p、delete [] p、allocator的区别

* `delete p` 用于释放通过 `new` 操作符分配的**单个对象**的内存，p是一个指向数据类型的指针，只会调用一次析构函数。
* `delete[] p` 用于释放通过 `new[]` 操作符分配的**对象数组**的内存，`p` 是一个指向 `int` 数组的指针
* 动态数组管理new一个数组时，[]必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数。
* new动态数组返回的不是数组类型，而是一个元素类型的指针，**指向数据类型的数组的第一个元素的地址。**
	* delete[]时，会**调用数组中每个元素的析构函数**
	* delete[]会直接释放存储数组的那一片内存块。
* allocator允许分配内存与初始化分离，先申请一片内存空间不进行初始化，需要的时候才进行初始化。

	* `allocator` 是 C++ 标准库中的一个模板类，它提供了一种类型安全的内存分配和释放方法。它主要用于容器类（如 `std::vector`、`std::list` 等）的底层内存管理。通过使用 `allocator`，容器类可以在运行时选择不同类型的内存分配策略。
	* **内存分配**：`allocator` 提供了 `allocate` 成员函数，该函数负责从堆上分配一块原始（未初始化）的内存。分配的内存大小由调用者指定，但分配的内存不会进行任何形式的初始化。这意味着分配的内存区域可能包含任何值，包括垃圾值。
	* **初始化**：在分配了内存之后，如果需要，可以使用其他机制（如构造函数调用、`std::uninitialized_fill`、`std::uninitialized_copy` 等）来初始化内存中的对象。这些函数可以在已分配但尚未初始化的内存上安全地创建对象。
	* **内存释放**：当不再需要已分配的内存时，应使用 `allocator` 的 `deallocate` 成员函数来释放它。重要的是要注意，`deallocate` 只负责释放内存，而不负责销毁或清理内存中的对象。如果内存中的对象已经初始化，那么在调用 `deallocate` 之前，应该确保这些对象已被适当销毁（例如，通过调用它们的析构函数或使用类似 `std::destroy` 的函数）。

	```c++
	#include <memory>  
	#include <iostream>  
	#include <type_traits>  
	  
	struct MyObject {  
	    MyObject() { std::cout << "MyObject constructed\n"; }  
	    ~MyObject() { std::cout << "MyObject destructed\n"; }  
	    void doSomething() { std::cout << "Doing something...\n"; }  
	};  
	  
	int main() {  
	    std::allocator<MyObject> alloc;  
	  
	    // 分配内存，但不初始化对象  
	    MyObject* p = alloc.allocate(1);  
	  
	    // 初始化对象  
	    alloc.construct(p); // 或者直接 new (p) MyObject();  
	  
	    // 使用对象  
	    p->doSomething();  
	  
	    // 销毁对象  
	    alloc.destroy(p); // 或者 p->~MyObject();  
	  
	    // 释放内存  
	    alloc.deallocate(p, 1);  
	  
	    return 0;  
	}
	```

	



## 4.8、c++为什么需要new/delete

* molloc/free和new/delete都是申请内存和回收内存的
* 对于非基本类型的对象使用的时候，**对象创建和销毁的需要执行构造函数和析构函数**，而molloc/free是库函数，已经编译好的代码，强加不合适。



## 4.9 operator new和malloc

* 所有的**空间配置（allocator）最终都会到底层实现的malloc**



```c++
void *operator new(){
	

}
```













# 5、静态链接和动态链接

## **5.1、符号与符号表**

**符号定义**：为程序中的实体（如变量、函数、类型等）分配一个唯一的名称

**符号引用**：代码中通过使用符号名来访问或操作已定义的实体。

局部变量、函数参数等临时变量temp分配在`栈`中，不会在过程外被引用，因此`不是符号定义`

![image-20240418104749492](全栈_C++.assets/image-20240418104749492.png)



**强符号：**函数名和已初始化的全局变量名

**弱符号： ** **`未初始化`的全局变量名**

**符号表：**符号表是程序/单元中“符号”的列表。符号通常是变量或函数的名称。**符号表可用于确定变量或函数在内存中的位置**。目标文件中有一个称为**符号表的数据结构**，**它将目标文件中的不同项目映射到链接器可以理解的名称**。

汇编过程：

源代码-->预处理-->编译-->优化-->汇编-->链接-->可执行文件

**预处理：**

读取c源程序，对其中的伪指令(#开头的指令)和特殊符号进行处理。包括宏定义替换、条件编译指令、头文件包含指令、特殊符号。最终生成一个没有宏定义、条件编译指令、头文件包含指令、特殊符号的输出文件。.i文件

**编译指令：**

编译程序所要作得工作就是通过词法分析与语法分析，再确认所有的指令都符合语法规则之后，将其翻译为等价的中间代码表示或汇编代码。.s文件

**汇编过程：**

将汇编语言代码翻译成目标机器指令的过程。.o文件

**链接阶段：**

将有关的目标文件彼此连接，也即将在一个文件中引用的符号同该符号在另一个文件中的定义链接起来

![image-20240418095421903](全栈_C++.assets/image-20240418095421903.png)

在链接阶段，根据编译器过程中处理方式的不同，链接可以分为静态链接和动态链接。

## 5.2、静态链接

静态链接

静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。

* 将所有需要的函数的二进制代码都包含到可执行文件中去，完成所有符号引用的一种链接方式。
* 静态链接库以.a/.lib作为文件后缀，
* 静态库会将代码打包进可执行文件中，在程序执行时可直接使用

符合解析：每个符号对应一个函数、一个全局变量、一个静态变量，符号解析的目的将每个符号引用与符号定义关联起来。

重定位：链接器通过每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使它们指向这个内存位置。

**优点：**

* 静态库直接将库打包进程序，最终可执行文件的执行比较快

**缺点：**

* 但是如果很多文件使用同一块静态库，那么打包后每个可执行文件都会有相同的静态库，占内存，
* 如果静态库需要更新的话，依赖静态库的程序也需要重新进行链接。





## 5.3、动态链接

特点：

* 在链接的时候，不直接拷贝相应的依赖库的代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，由操作系统将所需要的依赖库加载到内存中，然后**程序在运行到指定代码时，去执行内存中已经加载的依赖库的代码**，最终达到运行时链接的目的。
* 动态链接库以.so/.dll作为文件后缀。
* 动态链接库不会将代码打包到可执行文件中，而是打包动态库的名称等信息，每个程序只存放了动态库的虚拟地址，程序运行时会根据这些信息将动态库加载到内存中，才可以使用动态库中的代码。

优点：

* 动态链接可以实现进程间资源共享，程序A需要某一动态库中，再将动态库加载进入内存，当程序B也需要使用时，就不需要再加载了，两个程序共享动态库。



![image-20240418101242860](全栈_C++.assets/image-20240418101242860.png)









# 6、宏定义

## **6.1、宏定义和函数、typedef的区别**

**宏**：简单的字符替换，编译时编译器替换，定义的参数没有类型且运行时不存在函数调用，不进行类型检查，没有返回值，执行起来更快。

**函数调用：**运行时需要跳转到具体调用函数，具有返回值，参数具有类型，需要检查类型。

## **6.2、宏定义和typedef的区别**

* 宏主要用于定义常量即书写复杂内容，Typedef主要用于定义类型别名。
* 宏替换在**编译阶段之前（预处理阶段）**，属于文本插入；typedef是编译的一部分。
* 宏不检查类型，typedef会检查数据类型。
* 宏不是语句，不需要加分号，typedef是语句，加分号标识结束。
* 对指针的操作不同



## **6.3、变量声明和定义的区别**

* 声明仅仅是把变量的声明的**位置及类型**提供给编译器，并不分配内存空间；定义需要在定义的地方为其分配内存空间
* 相同变量可以在多处定义（外部声明extern），但是只能定义一次。
	* extern将一个文件的全局变量拓展到整个项目，实现变量在不同文件的共享
	
	

## **6.4、sizeof和strlen之间的区别**

* sizeof是运算符，不是函数，strlen字符处理的库函数
* sizeof参数可以是任何类型或者数据；strlen参数只能是字符指针且结尾是‘/0’结尾的字符串。
* sizeof值在编译时确定，所以不能用来得到动态分配（运行是分配）存储空间的大小。
	* c++中则调用_msize()函数获取动态分配内存空间大小
	* sizeof不能重载
	
	```c++
	const char *str = "name";
	sizeof(str);			// 取的是指针str的长度（存放name的地址），长度为8
	strlen(str);			// 取得是字符串的长度，不包含结尾的\0，长度为4
	```
	
	

## 6.5、宏定义和内联函数的区别

* 宏定义define只在**编译前**做了简单的字符串替换；而内联函数可以在**编译时**进行参数类型检查，且具有返回值。

* 内联函数在编译时直接将函数代码嵌入到目标代码中，在函数的调用点直接将函数的代码进行展开处理，省去函数调用的开销提高执行效率。并且进行**参数类型检查，具有返回值，可以实现重载。**

* 宏定义时要注意书写，否则容易出现歧义，内联函数不会产生歧义。

	内联函数使用场景：

	* 宏定义可以使用的地方都可以使用内联函数
	
	* 作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。(参考单例模式代码)
	
		
	

## 6.6、内联函数

```c++
#include<iostream>
inline int sum(int x,int y){
	return x+y;
}
int main(){
    int a = 10;
    int b = 20;
    //函数调用的开销：此处有标准的函数调用过程，包含函数压栈、函数栈帧的开辟和回退过程
    int ret = sum(a,b); //直接展开
}
```

当**函数调用的开销已经远远大于函数的执行开销**的时候可以使用内联函数：

* inline内联函数：在编译过程中，就**没有函数开销**了，在函数的调用点直接把函数的代码进行展开处理
	* 当编译器遇到内联函数调用时，它会在调用点将函数体的代码直接插入，而不是像普通函数调用那样进行栈帧的创建、参数的压栈和返回地址的保存等操作。

* inline函数不再生成响应的**函数符号**。
* **递归**不会被编译器处理成内联函数
  * inline只是建议编译器将函数处理为内联函数，并不一定声明就是内联函数
* **debug版本，inline是不起作用的**，因为要进行调试，只在release版本下才能出现

不能把所有的函数都写成内联函数：

* 当函数体内有循环，递归等，导致函数的执行开销远远大于函数调用，内联没有意义
* 函数体内的代码较长时，将导致内存消耗太大



## 6.5、NULL与nullptr

**NULL:**

* c语言中NULL被定义为(void *)，c++中NULL被定义为整数0
	* c++允许函数重载，如果把NULL作为参数，无法分辨整数和指针的区别

**nullptr:**

* nullptr是明确的指针类型。
* 可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误











# **7、struct和class**

## 7.1、struct和class的区别

**相同点：**

* 两者都有成员函数、共有和私有部分。
* 任何可以使用class完成的工作，是同struct同样可以完成

**不同点：**

* 当不指定成员的公私有时，struct默认共有，class默认私有。
* struct默认共有继承、class默认私有继承；
* class是引用类型，实例化时在堆中分配空间，栈中保存的只是引用（地址）；struct是值类型，在栈中分配空间。



## 7.2、 class中三种接口的访问和继承权限

**访问权限**

1. public：
	* 成员（包括成员函数和成员变量）可以被任何外部代码访问。
	* 在类的继承中，public成员在派生类中保持其public属性，除非在派生类中被重新声明为其他访问级别。
2. protected：
	* 成员只能被其所在**类的成员函数、友元函数、派生类（无论通过哪种继承方式）的成员函数访问**。
	* 在类的继承中，protected成员在派生类中保持其protected属性，除非在派生类中被重新声明为其他访问级别（但通常不会声明为private，因为这将限制派生类对基类成员的访问）。
3. private：
	* 成员只能被其所在**类的成员函数和友元函数**访问。
	* 在类的继承中，**private成员在派生类中是不可见的**，即派生类无法直接访问基类的private成员。

**继承权限**

C++中的继承权限决定了派生类如何访问基类中的成员。

1. public继承：
	* 基类中的public成员在派生类中保持为public。
	* 基类中的protected成员在派生类中保持为protected。
	* 基类中的private成员在派生类中仍然不可见。
2. protected继承：
	* 基类中的public和protected成员在派生类中变为protected。
	* 基类中的private成员在派生类中仍然不可见。
	* 这种继承方式较少使用，因为它限制了派生类外部对基类成员的访问。
3. private继承：
	* 基类中的所有成员（public、protected、private）在派生类中均变为private。
	* 这种继承方式主要用于实现接口隐藏或代码复用，但通常不推荐使用，因为它极大地限制了派生类的使用灵活性。
	* **注意：**实时上**继承会将基类的所有成员继承，但是由于private权限限制，派生类无法访问，没有private成员的访问路径。**





# 8、const和static

## **8.1 、const和static的区别**

**static：**

* **不考虑类的情况下：**
	* **隐藏。** **加了static的全局变量和函数只能在本文件所在的编译模块中使用**，将全局变量的外部链接属性修改为内部链接属性。
		* 当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。
	* **默认初始化为0，**包括未初始化的全局变量和静态变量，都保存在数据段中的.bss段中。
		* 全局变量也具有这一特性，因为全局变量和静态变量都存放在静态数据区(.bss和.data)，在静态区，所有的字节默认值都是0x00。
	* **static在函数内部调用，始终存在**，**只进行一次初始化**，不会被释放掉，**具有全局变量特性**，改变了其生存周期。
		* static局部变量在编译前就要分配内存空间，存储在静态数据区的变量也会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
		* 全局变量和static对象会在首次使用时(在代码出现的顺序)才会进行构造，并通过atexit()进行管理，程序结束时，按照构造的反方向进行析构调用。

```c++
void func(){
    int s_num = 0; //每次
	static int num = 0; //只初始化一次
	num++;  //不释放
    cout << s_num << endl;
	count << num <<endl;
}
for(int i = 0;i<3;i++){
	func();
}   //s_num: 0 0 0  num: 1 2 3
```

* **考虑类的情况下**：
	* **static成员变量**:
		* 无论创建多少个类的对象，静态成员变量**只有一个副本存在于内存中**，它们是**与类本身关联的，而不是与类的对象关联的**。
		* **只与类关联，不与类的对象关联**，在类的命名空间中。static成员变量在编译阶段就要分配内存空间。**因此是共享的，不属于具体某个对象**，在**类内声明，类外初始化**，初始化时不需要标为static；可以被非static成员函数任意访问。
			* 通常存储在全局数据区（静态存储区）
				* 初始化为0，或者未初始化存在.bss段
				* 初始化非0.存在.data段
			* `static`成员变量的**内存分配发生在运行时**，它们的地址在编译后就已经确定了
		* 可以通过对象和类名进行调用
		* 也有访问权限，`static`成员**没有与类的任何特定对象实例相关联的`this`指针**，不能访问private数据
	* **static成员函数**：
		* **不具有this指针**，**只能访问类的static成员变量**，**不能被声明为const、虚函数和volatile**；
			* 没有this指针，所有不能被virtual修饰，**static本身也不属于任何对象或者实例,属于整个类所拥有，所以加上virtual没有实际意义**，而且虚函数的实现是为每个类对象分配一个vptr指针，但是**虚函数指针是通过this指针调用的**。
		* 可以被非static成员函数任意访问：因为静态成员为所有类对象所共享。
		  * 不能访问非static成员：因为没有与之关联的特定对象，也没有 `this` 指针来引用对象的成员变量，无法区分某一个成员变量到底修饰的那个对象。
		  * 不能访问非static成员函数：因为没有this指针
		* 可以通过对象和类名进行调用
		* 也有访问权限，不能访问private数据
* c/c++标准为全局/静态对象是首次用到时才会进行构造，并进行atexit()来管理，
* 在程序结束后，按照构造顺序反方向进行逐个析构，所以在c++中允许使用变量对静态局部变量进行初始化

```c++
class Student{
public:
	static int m_a;    
};
int Student::m_a = 10;
Student A; 
A.m_a = 100;
Student B;
B.m_a = 200; 
cout << A.m_a << endl; //这里通过对象访问数据，最终的m_a就是200，因为所有对象共享,即使通过A.m_a调用，但是B.m_a已经修改了。
cout << Student::m_a << endl; //这里也是类外初始化的原因，可以直接通过类名来访问数据，通过对象访问要调用构造函数进行初始化，但是通过类名访问，不需要经过构造函数初始化，因此需要类外初始化
```

 **const:**

* 不考虑类的情况：
	* const常量在**定义时必须初始化**，**之后无法修改**。
	* 在函数声明中。**const可以修饰形参**，表示它是一个输入参数，**在函数内部不可以修改其值**。
		* const形参可以接收const和非const类型的实参.
* 考虑类的情况
	* **const成员变量**：不能在类定义外部初始化，**只能通过构造函数初始化列表进行初始化**，**并且必须有构造函数**；不同类对其const数据成员的值可以不同，所以不能再类中声明初始化。
	* **const成员函数**：表明这是一个**常函数**，不能修改类的成员变量
	  * **const对象只能调用类的const成员函数**；非const对象都可以调用，不可以改变非mutable数据的值。
	  	* **mutable**：和const是相反的，让变量永远处于可变状态，可以突破const限制，可以在const修饰的成员函数中修改成员变量。
	  * const成员函数可以访问：非const对象的的非const数据成员、const数据成员、const对象内的所有成员。

```C++
class person{
public:
	int m_a;
    mutable int m_b;
    void add() const{ //const修饰成员函数
		m_a = 10;  //错误，不可修改，this指针已经被const修改为指针常量
        m_b = 20； //正确
    }
}
```

**problem:**

如何在main函数的函数体执行之前就打印文本？

* 单例模式—>static:static成员变量编译前便要分配内存。**类在实例化时在分配内存空间，static先于类的创建**

```C++
class Student{
private:
    Student(){cout << "先输出" << endl;};
    Student(const Student &s){}
    static Student *stu;
public:
    static Student *getInstance(){
        return stu;
    }
};

Student *Student::stu = new Student;

void test(){
    Student *p=Student::getInstance();
}

int main(){
    cout << "后输出" << endl;
    test();                 //这里test尽管在上后面的输出文本后面，但是由于static成员变量在编译结点就要分配内存空间，也就会							执行Student *Student::stu = new Student;语句并调用其相关构造函数。
}
// 先输出
// 后输出
```

**static成员变量为什么在数据段？**

1. **生命周期**：数据段（包括全局和静态存储区）用于存储那些在整个程序执行期间都存在的变量。`static`成员变量不属于任何特定的对象实例，而是属于类本身。因此，它们的**生命周期与程序的整个运行时间一样长，这符合数据段的特性**。
2. **初始化**：`static`成员变量**必须在程序开始执行之前就被初始化**。这意味着它们不能在运行时被动态地分配内存。**数据段是在程序加载时就已经分配好的内存区域**，因此`static`成员变量被放置在这里以便在程序启动时就能被正确地初始化。
3. **共享性**：虽然`static`成员变量存储在数据段中，但这并不妨碍它们被类的所有对象共享。存储位置的选择主要是基于其生命周期和初始化需求，而不是基于其共享性质。实际上，由于`static`成员变量只有一个实例，所以无论你从哪个对象访问它，你都会得到相同的值。
4. **作用域**：`static`成员变量的作用域是全局的，这意味着它们可以在程序的任何位置被访问（当然，通过类的作用域解析运算符`::`）。将它们放在数据段中有助于确保这种全局访问性。

**static变量和全局变量的区别：**

* 隐藏，且static只初始化一次，防止在其他文件单元被引用。



## **8.2、顶层const和底层const**

* **顶层const**：（int * const p = &a）指的是const修饰的指针本身是一个常量，不能改变 `p` 所指向的地址，但可以修改 `p` 所指向的值。
* **底层const**：（int const *p = &a）指的是const修饰的变量所指向的对象是一个常量。可以改变 `p` 所指向的地址，但不能通过 `p` 修改它所指向的值。

**区分：**

* 执行对象的拷贝时有限制，常量的底层const不能赋值给非常量的底层const。
* 使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const。



## 8.3 全局变量和static变量的区别

* 全局变量和静态变量都存放在全局/静态存储区。
* 全局变量的作用域是整个源程序，项目的其他源文件在各个源文件都是有效的。静态变量的作用域只在定义该变量的源文件内有效。



# 9、关键字

## 9.1、分清重写、重载和隐藏

**重载(overload)**：

​		通过是**同一个类**当中由两个及两个以上的同名函数，但是其有不同的参数列表，重载和函数是否是虚函数无关。

**重写(override)**：

​		派生类的重写了父类中的同名同形参的虚函数，但是其函数体不同，重写要求与基类虚函数有相同的参数个数，参数类型，返回值类型。

**隐藏(overwrite)**：

* 是指基类函数，无论它是**否为虚函数**，当派生类出现同名函数时，如果**函数形参不同于基类函数**，则基类函数会被**隐藏**,即调用的话调用的是派生类的成员变量和成员函数。
* 如果**派生函数与基类形参相同**，则需确定基类函数是否是虚函数，如果**是虚函数则是重写**，否则基类也会被隐藏。
* 和重载的区别也是不在一个类中。

**重载和重写的区别：**

* 重载是在同一个类中。重写是在具有继承关系的父类和子类之间
* 重载要求参数列表不同，对返回值没有要求；重写要求与基类虚函数有相同的参数个数，参数类型，返回值类型。
* 重载根据调用时的实参表参与形参表的对应关系来选择函数体，重写的调用方法根据对象类型决定。

**override**

override的作用是**指定子类函数要重写父类的虚函数**，当编译错误时，编译器不会将其当作新函数进行编译。

```c++
calss A{
public:
	virtual void func();  
}；
class B:public A{
	virtual void func() override; //指定子类是父类虚函数的重写
};
```

**final**

当**不希望某个类被继承，或者不希望某个虚函数被重写**，可以在类名后或者函数后添加final关键字。

```c++
calss A{
public:
	virtual void func() final;//无法被重写
}；
class B:public A{
	virtual void func(); //会报错
};
class C final:B{  //指明C是不可以被继承的
	void func();
} 
```



## **9.2、explicit**关键字

* 用来修饰类的构造函数的**声明**上
* 作用于**单个参数**的构造函数

```c++
Struct B{
	explicit B(int){}
	exclicit operator bool const(return true);
}
```

* explicit关键字修饰构造函数时，**不允许**出现**隐式类型转换**和**复制初始化**（拷贝初始化）。

```c++
A a = 1; //不允许，复制初始化
A a2 = {1};//不允许，复制列表初始化
A a3 = (A)1; //允许static_cast的显示转换
A a4 = a3; //不允许，隐式转换
```

* explicit关键字修饰转换函数时，可以防止隐式类型转换，但**按语境转换**除外。

```c++
A a(1); //直接初始化
bool a2(a); 0//按语境转化，bool中除了0时false，其他都是true
```



## 9.3、extern关键字

* 声明全局变量：有一个全局变量（即在所有函数之外定义的变量），并且你希望在其他文件中也能访问这个变量，需要在那个文件中使用`extern`来声明这个变量
* 函数默认就是`extern`的。

```c++
//xx.h
extern int add(...)
extern int globalVar; // 声明全局变量，但不在这里定义 

//xx.c
int add(){}

//xx.cpp
extern "C"{
    #include "xx.h"
}
```



## 9.4、volatile关键字

**概念：**

volatile关键字和const关键字对应，修饰变量时，编译器对访问该变量的代码就不再进行优化。

* `volatile` 关键字在 C++（以及 C）中用于告诉编译器，某个变量的值可能会在程序的控制之外被改变。这意味着编译器在优化代码时，不能假设这个变量的值在两次访问之间保持不变，也不能对其进行优化（比如缓存其值到寄存器中），因为其他线程或外部事件（如硬件中断）可能会修改这个变量的值。

* 能**保证对特殊地址的稳定访问**。
* **防止指令重排序**,保证其指令的执行顺序与程序指明的顺序一致，不会发生顺序变换
	* 编译器对代码的优化：
		* 对于以下代码，当编译器发现两次从i读数据的代码之间没有对i进行操作，他就会把上次读的数据保存再b中，而不是从i里面重新读取，这样的话，当i是一个寄存器变量或者表示一个端口数据就容易出错，因为一般的**对象编译器或将其拷贝放在寄存器中用以加快指令的执行速度。**


```c++
volatile int i = 10;
int a = i;
...
int b = i;
```

​	**volatile指出变量是随时可变的**，每次使用一个变量必须从其地址中读取,即**系统总是重新从它所在的内存中读取数据**，因此每一时刻线程读取到该变量的值都是内存中**最新的值**。

**使用环境：**

* 中断服务程序中修改的供其它程序检测的变量需要加volatile； 
*  多任务环境下各任务间共享的标志应该加volatile，即多线程并发共享变量时； 
*  存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

**volatile指针**：

与const修饰此类似，volatile也有：

* 修饰由指针的指向的对象，数据时const（指针常量）、或者volatile的：

```c++
volatile char *pre;
```

* 指针自身的值，一个代表地址的整数变量时const（常量指针）、volatile的

```c++
char *volatile pre;
```

**多线程下的volatile**：

当多个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile，该关键字会防止优化编译器把变量**装入到CPU内存寄存器**中，如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这回造成程序的错误执行。

```c++
volatile BOOL bstop = False；

//一个线程
while(!bstop){}
bstop = false;
return;

//另一个线程
bstop = True;
while(bstop); //等待上面的线程终止
```

如果bstop不使用volatile申明，那么这个循环将是一个死循环，因为bstop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE，加上volatile，程序在执行时，每次均从内存中读出bstop的值，就不会死循环了。

**底层实现原理：**

保证可见性与有序性

**可见性：**

* 当一个变量被声明为 volatile 时，它会告诉编译器和CPU将该变量存储在主内存中，而不是线程的本地内存中。即每个线程读取的都是主内存中最新的值，**避免了多线程并发下的数据不一致问题**。

​		当线程A和线程B都保存了a变量的本地内存副本，当线程A的a被修改时，会立马将数据更新到主内存，同时当B要使用变量a时，会清除线程B的本地内存副本数据并同步主内存数据。

![image-20240330140920923](全栈_C++.assets/image-20240330140920923.png)

**有序性：**

* 重排序可以分为**编译器重排序和处理器重排序**，valatile保证有序性，就是通过分别**限制这两种类型的重排序**。

![image-20240330141607128](全栈_C++.assets/image-20240330141607128.png)



为了实现volatile的内存语义，编译器再生成字节码时会在指令序列中插入**内存屏障**来禁止特定类型的处理器重排序。

* 在每个volatile写操作的前面插入一个StoreStore屏障
* 在每个volatile写操作的后面插入一个StoreLoad屏障
* 在每个volatile读操作的后面插入一个LoadLoad屏障
* 在每个volatile读操作的后面插入一个LoadStore屏障

![image-20240330141958251](全栈_C++.assets/image-20240330141958251.png)



## 9.5、using 关键字

可以改变基类成员在派生类中的访问权限

* 但是只能改变基类中public和protected成员的访问权限，不能改变private成员的访问权限。

```c++
class person {
public:
    int m_a = 10;
protected:
    int m_c = 30;
};
class student:public person{
public:
    using person::m_c;  //把基类中的protected属性m_c改为public
private:
    using person::m_a; //把基类中的public属性m_a改为private
};
student stu;
stu.m_c = 10; //原本是不能访问的，但是using关键字把基类中的protected属性m_c改为public，便可以操作
```



## 9.6、noexcept关键字

* 当一个函数被标记为`noexcept`时，编译器可以假设该函数不会抛出异常，并据此生成更高效的代码。如果这样的函数确实抛出了异常，程序会调用`std::terminate`来终止执行，这通常会导致程序崩溃。
* 在移动构造函数和移动赋值运算符中使用`noexcept`是特别重要的，因为移动操作通常不会失败，并且不应该抛出异常。如果移动操作抛出异常，那么它可能会破坏源对象和目标对象的状态，导致资源泄漏或其他未定义行为。



## 9.7、final关键字

* 希望某个类**不被继承**
* 希望某个虚函数**不被重写**

```c++
class Base{
	virtual void foo();
};
class A : public Base{
	void foo() final;		//foo被override且是最后一个override，其在子类中不能被重写
};
class B final :A{			//指明B是不可以被继承的
	void foo() override;	//错误，foo已经在A中被final了，不能被重写
};
class C：B{};				//错误，B已经被final了不能被继承
```



## 9.10 auto占位符

* 声明变量时根据初始化表达式**自动推断该变量的类型**、声明函数时函数返回值的占位符

	```c++
	#include <iostream>  
	#include <vector>  
	  
	int main() {  
	    std::vector<int> v = {1, 2, 3, 4, 5};  
	  
	    // 使用auto自动推导类型  
	    for (auto it = v.begin(); it != v.end(); ++it) {  
	        std::cout << *it << ' ';  
	    }  
	  
	    // 或者在C++11及更高版本中，使用基于范围的for循环  
	    for (auto elem : v) {  
	        std::cout << elem << ' ';  
	    }  
	  
	    return 0;  
	}
	```

* `auto` 关键字不能用于函数参数的声明中。
* 使用 `auto` 时，必须同时进行初始化，因为编译器需要通过初始化表达式来推导类型。
* 在某些情况下，为了避免混淆或明确类型，即使可以使用 `auto`，也建议显式指定类型。



# 10、面向对象的三大特性

## 10.1、封装

C++引入class这个类的概念，将数据和操作数据的方法（代码）封装捆绑在一起，避免外界干扰和不确定性访问。也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或对象操作，对不可信的进行隐藏。

* 例如在类中：
	* 将公共的数据或方法使用public修饰，而不希望被访问的数据或方法使用private修饰。

```c++
classname Memmber; //将类的实例化这样一个变量起名为对象，因此面向对象编程
```



### 10.1.1 类的权限

**访问权限：**

* public修饰的变量和函数，在类的内部和外部都可以访问
* private：修饰的元素只能在类内访问
	* 私有成员只能被类的成员函数或友元函数访问，这是封装性的一种体现，用于隐藏类的内部实现细节，只允许通过类的公有接口（如公有成员函数）与外部交互。但**成员函数本身**并不受这个限制，因为**它们是类内部的一部分，有权访问类的所有成员**。

* protected：修饰的变量和函数只能在类内和派生类中访问

派生类可以继承基类中除了构造/析构/赋值运算重载函数之外的成员，但这些成员的访问属性在派生类中也可以调整，只有当**基类和派生类的修饰符都是public时**，外部才可以访问。

**继承权限：**

* public继承（公有继承）：父类成员在子类中保持原有的访问级别
* private继承（私有继承）：父类成员在子类中变为private成员
* protected（保护继承）：父类中public成员会变成protected，父类中protected、private成员仍是protected、private。
* 如果继承时不写则默认派生类为class是private继承，而派生类为struct默认是public继承

```c++
class student::public/protected/private person{};
```

**子类和父类的关系：**

继承只是通过父类可以快速构建子类的语法技术，继承后得到子类和父类是两个独立的类。

子类的对象和父类的对象是两个独立的对象，没有任何关系，只是在构建过程的模板有部分相同。





## 10.2、继承

让某种类型对象获得另一个类型对象的属性和方法。

### 10.2.1 继承的三种方式：

* 实现继承：指使用基类的属性和方法而无需额外编码的能力
* 接口继承：仅使用属性和方法的名称、但是子类必须提供实现的能力。
* 可视继承：子类使用基类的外观和实现代码的能力（c++不怎么用）

```c++
class person {
public:
	int m_age;
	string m_name;
	string m_tel;
public:
	person() {
		m_age = 18;
		m_name = "zhangsan";
		m_tel = "111";
	}
	void sing() {
		cout << "唱歌" << endl;
	}
	void setname(const string &name) {
		m_name = name;
	}
	void set_tel(const string& tel) {
		m_tel = tel;
	}
};

class student :public person {
public:
	string xingbie;
public:
	student() { xingbie = "女"; }
	void show() {
		cout << m_age << m_name << m_tel << xingbie << endl; //这里的m_age、m_name、m_tel都是父类的
	}
};

int main() {
	student stu;
	stu.show();  //18zhangsan111女  //这里stu能继承父类的所有成员变量和成员函数
	return 0;
}
```

![image-20240331160254452](全栈_C++.assets/image-20240331160254452.png)





### 10.2.2 继承的对象模型

* 创建派生类对象时，先调用父类的构造函数，再调用子类的构造函数
* 销毁派生类对象时，先调用派生类的析构函数，在调用基类的析构函数（**先构造的后析构，后构造的先析构**）
	* 这里需要注意的是，c++**强制规定**了如果执行了派生类的析构函数，那么接下来必须执行基类的析构函数。
* 创建派生类对象只会申请一次内存，**派生类对象包含了基类对象的内存空间**，**this指针相同**。
* 使用sizeof计算派生类对象的空间大小，得到的是基类的所有成员（包括私有成员）+派生类对象所有成员的大小。
* 基类的private成员在类外是不能访问的，在派生类中也是不可见的，但是**如果直接操作内存，可以用指针突破语法限制**。
	* memset函数：void *memset(void *s, int c, size_t n);可以将每一块内存中的全部设置为指定的值。
* 继承时，基类的**构造函数、析构函数、赋值运算符和友元函数**都无法继承。



### 10.2.3 基类的构造

派生类的构造函数：

* 创建派生类对象时，先调用父类的构造函数，再调用子类的构造函数
* 如果没指定基类构造函数，将使用基类的默认构造函数
* 可以用初始化列表指明要使用的基类构造函数 

```c++
class person{
public:
    int m_age;
    string m_name;
public:
    person():m_age(0),m_name("wangbadan"){} //初始化列表
    person(int age,string name):m_age(age),m_name(name){}
    person(const person &per):m_age(per.m_age),m_name(per.m_name){}
};
class sutdent:public person{
public:
    int height;
    student():height(0){}
    stuent():height(0),person(){} //调用基类的默认构造函数
    //用初始化列表指明要使用的基类构造函数 
    student(int age,string name,int height):person(age,name),height(height){} //调用基类的第二个初始化列表构造函																			数，前两个age和name参数是给基类的
    student(const person &per,int height):A(a),height(height){} //调用基类的拷贝构造函数
}
```





### 10.2.4 名字遮蔽和类作用域

当派生类成员函数或者成员变量和基类的重名时：

* 如果形参不同，则会被隐藏（关键字overwrite），即通过构造子类对象调用时，调用的时子类中的成员。
* 如果形参相同，基类的成员函数为虚函数则是重写（关键字override），如果不是，还是隐藏。





### 10.2.5 继承的特殊关系

* 如果继承方式是公有的，则派生类对象可以使用基类成员
* 可以把**派生类对象赋值给基类对象（包括私有成员），但是会舍弃非基类的成员**,也就是说可以用子类赋值给父类，但是父类无法调用子类的成员变量和函数。
	* 如果你试图将一个派生类对象赋值给一个基类对象（而不是指针或引用，而是直接赋值），会发生**对象切片（slicing）**，这会导致派生类中继承自基类之外的所有部分（即派生类特有的成员变量和成员函数）都会被丢弃，只保留基类部分的副本。
		* 这种行为的根本原因是在C++中，**基类和派生类在内存中通常是以不同的方式布局的**。基类部分位于派生类对象的起始位置，但派生类可能还包含额外的成员变量和成员函数，这些都不在基类的布局中。当你试图将一个派生类对象赋值给基类对象时，由于基类对象没有足够的空间来存储派生类特有部分，因此编译器只能复制基类部分的数据，而忽略派生类特有的部分。
	
* 基类指针可以在不进行显示转换的情况下指向派生类对象
* 基类引用可以在不进行显示转换的情况下引用派生类对象
	* **基类指针或引用只能调用基类的方法，不能调用派生类的方法**
	* 可以用派生类构造基类
	* 如果函数的形参是基类。实参可以用派生类。
		* **用派生类给基类对象赋值，本质上是调用基类的赋值函数**

	* C++要求指针和引用类型与赋给的类型匹配，这一规则对继承来说是例外，
		* **当使用多态时，基类指针可以直接操作子类空间**。


```C++
class A{
public:
	int m_a;
private:
	int m_b;
public:
    A():m_a(0),m_b(0){}
    void show(){cout << m_a << m_b << endl;}
    void setmb(const int &b)
        m_b = b;
    }
}
class B:public A{
public:
    int m_c = 100;
    void show(){cout << m_c << endl;} 
}
int main(){
    B b;
    A *a = &b;  //类是自定义数据类型，如果不是虚函数，通过基类指针只能操控基类的空间
    a.show();  //如果A中的show是虚函数，那么调用的就是子类B的show函数，但是这里没有virtual，所以调用的是父类A的show()
    B b;
    b.show(); //通过对象B
}
```

**注意：**

* 如果**将某个类用作基类**，**该类必须定义而非声明**。
* 在类中写 `int m;` 是一个成员变量的声明，同时也是一个定义。在C++中，当你在类定义中声明一个成员变量（如 `int m;`），这既是一个声明，告诉编译器类中有一个名为 `m` 的整数类型的成员，同时也是一个定义，因为它在类的上下文中为 `m` 分配了空间。
* 对于非静态成员变量，它们实际上是在每个类的实例（对象）中分配空间的，而不是在类本身中。因此，`int m;` 的定义是针对每个对象的，而不是针对类本身的。类定义只是说明了对象将包含哪些成员变量和成员函数。

 

## 10.3、动态多态

### **10.3.1 虚函数：**

```c++
class A{};
class B{                                    
public:										
	void func1(){}                             
	void func2(){}
};
class C{
public:
    void func1();
    void func2();
    virtual void func3();
};
A a;  //sizeof(a) == 1; 类的实例化存储在堆中，大小至少为1
B b;  //sizeof(b) == 1; 类的成员函数属于类的组成部分，不会占类对象的内存空间
C c;  //sizeof(c) == 4; 当引入虚函数进类中，编译器会向类中插入成员变量虚函数表指针(vptr)，其大小根据位数不同而不同
```

* **虚函数指针：**在含有虚函数的类**实例化对象**时，对象地址的**前四个字节**存储的**指向虚表的指针**，因此虚函数指针的存放位置和申请对象的位置有关，new的话就是在堆中，对象在栈中就是在栈中。
	* 对于有虚函数的类在编译时，编译器会向类的**构造函数中添加为虚函数指针赋值的语句**，当创建类的对象时，会执行构造函数，便会使**vptr指向类的vpbl**。
	* **两次赋值：**在继承层次中，由于先构造父类，因此会先将基类的虚表地址赋值给父类的虚函数表指针。在子类构造初始化时，又会初始化将子类的虚表地址赋值给子类的虚函数指针。
* **虚表：**当类中存在至少一个虚函数时，编译器会在**编译期**间为类生成一个**虚函数表**(virtual table)，来**支持动态绑定和多态性**。当编译、链接生成可执行文件后，这个类及伴随此类的虚函数表会保存在可执行文件中，在可执行文件执行时，也会**一同放入内存**当中。
	* 虚表的创建时机：当编译时，编译器发现类中有virtual字段时就会生成虚函数表。而**虚函数表存放的位置是全局数据区的只读数据段中**，虚表中存放的是**函数指针**，虚表是存放虚函数地址的数组。
* **构造函数不能声明为虚函数**，构造函数是为了初始化对象的状态，而虚函数是为了实现多态，当构造一个对象时，对象的内存里面有虚函数指针，虚函数指针指向类的虚表，虚表存放虚函数地址，对象没有完全构造完成是无法使用虚函数的。
	* 虚函数表通常包含了对象的所有虚函数的地址，而这些地址只有在对象完全构造后才能确定

* **inline函数**（直接嵌入）不能声明为虚函数，因为inline函数没有地址，无法存放到虚表中。

​		

![image-20240328160743013](全栈_C++.assets/image-20240328160743013.png)

**c++中什么函数不能声明为虚函数：**

1. **静态成员函数**：静态成员函数属于类本身，而不是类的任何特定对象。因此，它们不能是虚函数，因为虚函数的机制依赖于对象的类型信息（通过虚函数表实现），而静态成员函数不依赖于任何对象实例。
2. **友元函数**：友元函数虽然可以访问类的私有和保护成员，但它们不是类的成员函数，也不属于任何类的作用域。因此，友元函数不能声明为虚函数。
3. **构造函数**：构造函数用于初始化对象，其执行时机在对象创建时。由于虚函数表是在对象创建之后根据对象的实际类型来填充的，因此在构造函数执行时，对象的类型（以及相应的虚函数表）尚未完全确定。因此，构造函数不能是虚函数。同样地，析构函数虽然可以是虚函数（并且经常是），但构造函数却不能。
4. **内联函数**：虽然技术上内联函数可以声明为虚函数，但这样做通常没有意义。内联函数的目的是在编译时展开函数体以减少函数调用的开销，而虚函数的调用则涉及到在运行时确定调用哪个函数。将虚函数声明为内联函数可能会破坏这种机制，并导致编译器忽略内联请求。
5. **简单且频繁调用的成员函数**：虽然这不是一个绝对的规则，但对于那些简单且频繁调用的成员函数，将它们声明为虚函数可能会引入不必要的性能开销。因为每次调用虚函数时，都需要通过虚函数表来查找实际要调用的函数。
6. **不需要多态行为的成员函数**：如果某个成员函数不需要根据对象的实际类型来调用不同的实现，那么将其声明为虚函数是没有必要的。



### 10.3.2 多态

**概念：**

* 同一事物表现出不同事物的能力，即不同对象发送同一消息，不同的对象在接收时会产生不同的行为，**重载/模板实现编译时(静态)多态，虚函数和虚函数表实现运行时(动态)多态。**
	* **函数重载**：允许在同一个作用域内定义多个名称相同但参数类型或参数个数不同的函数。编译器在编译时根据调用时传递的参数类型或个数来确定具体调用哪个函数。
	* **模板**：通过模板可以定义与类型无关的函数或类，编译器会根据实际使用的类型来生成相应的函数或类。

* 多态是在不同继承关系的类对象，去调用同一函数。当类中定义了虚函数，而我们要去调用这个虚函数，才存在了多态的可能。


**核心思想：**

* 用基类指针指向派生类对象，结合虚函数技术，调用派生类的成员函数。


**多态调用虚函数：**

普通的代码中二进制文件就有成员函数的地址

* 创建基类指针，让他指向派生类对象，用基类指针调用派生类的成员函数。
* 通过虚函数指针找到虚函数表，通过查询虚函数表找到虚函数的入口地址并执行虚函数。


**多态的调用：**

* 程序中既存在父类也存在子类，父类中必须含有虚函数，子类中也必须重写父类中的虚函数。
*  父类指针指向子类对象，或父类引用绑定子类对象，即**父类指针指向子类空间**。

```C++
class Base{
public:
	virtual void myfunc(){
        cout << "父类" << endl;
    }
};
class pre:public Base{
public:
    void myfunc() override{  //重写
		cout << "子类" << endl;
    }
};
Base *p = new pre();  //Base *p = nullptr; p = new pre;
p->myfunc();  //子类（多态调用）

Base base;
base.myfunc(); //父类（直接调用，不是多态）
pre pr;
Base *pa = &pr; 
pa->myfunc(); //多态调用（引用），调用的子类

delete p; //这里仍然需要释放--
//智能指针可以不用释放
unique_ptr<Base> p = make_unique<pre>();
p->myfunc();
```

![image-20240328163140985](全栈_C++.assets/image-20240328163140985.png)





### 	  10.3.3 动态绑定机制：

​		虚函数(动态多态)才有动态绑定。

​		派生类会继承基类的虚表指针和虚表(这也是为了让基类和派生类保持相同的内存模型)，派生类对基类的虚函数**没有重写时**，派生类的虚表指针指向的是派生类的虚表，但是虚表当中的虚函数地址仍是基类中的虚函数地址；**当有重写时**，派生类的虚表中的被重写的函数地址将会**覆盖原本的基类中的函数地址**，此时通过指针去调用，**指针所操作的空间是由其指向的类型决定的**，指针是由父类定义的，其实调用的还是基类的函数，但是由于是虚函数，当通过虚函数指针去查找虚表时，虚表中被重写的函数的地址已经不同，调用的是子类重写的函数，这属于**间接调用**；当派生类有自己的虚函数，在自己的虚表中将此虚函数地址添加在后面。

* 虚表在没有重写时派生类和基类的是完全一莫一样的。重写后内容发生变化会区分开
* 基类和派生类虚函数表指针的区分（通过调用的对象区分）：父类指针调用的是派生类对象，而虚函数指针存放在对象的前几个字节的地址，因此调用基类对象会调用基类的虚函数指针并指向基类的虚表，调用派生类对象会调用派生类的虚函数指针并指向派生类的虚表。

**动态绑定的实现：**

```c++
class A{
    virtual func(){}
    A()
	virtual ~A(){} //这样通过父类指针调用的就是派生类的析构函数
}；
class B:public A{
    func() override{}
    B()
    ~B(){}
};
B b; //先调用父类的构造。再调用派生类的构造
A *a = new B(); //指针实现
a.func(); //B:func()
b.func(); //B:func()
A &a = b; //引用实现
a.func(); //B:func()
b.func(); //B:func()
```



### 		10.3.4 纯虚函数：

```C++
class A{
public:
	virtual void func(void) = 0; //纯虚函数
}；
```

* 一旦类中由纯虚函数，那么该类就是抽象类
	* **抽象类不能实例化对象**,但仍可以使用基类指针或者引用来操控派生类空间；
	* 抽象类必须被继承，同时子类必须重写父类的所有纯虚函数，否则子类也是抽象类；
	* 抽象类的主要目的是设计类的接口，实现多态。





### 		**10.3.5 虚析构**

在父类指针申请了(new)临时指针指向子类空间，是要进行释放的的，但是这里由于指针是父类的类型，delete只会调用父类的析构，并不会调用子类的析构，不会释放子类析构，这样只申请不释放，会造成**内存泄漏**，因此父类的析构函数前面也要加virtual，这样就**可以通过父类指针释放掉所有子类空间**。

* 通过将基类的析构函数声明为虚函数，可以确保在通过基类指针删除派生类对象时，能够调用到派生类的析构函数。这是因为在对象被删除时，C++的运行时环境会查找该对象的实际类型（即最派生类），并调用其析构函数。由于析构函数的调用是通过虚函数表（vtable）来实现的，因此如果基类的析构函数是虚函数，那么运行时环境就能够找到并调用正确的析构函数。

```c++
class A{
    A()
	virtual ~A(){} //这样通过父类指针调用的就是派生类的析构函数
}；
class B:public A{
    B()
    ~B(){}
};
A a; //只会调用调用类的构造函数和析构函数
B b; //先调用父类的构造。再调用派生类的构造
A *a = new B;
delete a; //只会调用基类的构造和析构，然后调用派生类的构造函数，但是不会调用派生类的析构函数，解决方法->将析构函数也设置为				virtual
a = nullptr;			
```

​		子类的析构函数也是通过从父类所继承的虚函数指针所调用，而虚函数表中的析构函数地址会自动修改为子类析构函数地址，不用进行重写。在析构了子类之后，也会自动调用父类析构。

![image-20240329094635617](全栈_C++.assets/image-20240329094635617.png)

​		**补：**

​		即使派生类不重写析构函数，基类也应该写上虚析构函数，因为通过父指针无法操控派生类的成员函数和成员变量，因此必须写上虚析构。





### 10.3.6 纯虚析构

* 纯虚析构（pure virtual destructor）实际上并不是一个合法的C++概念。在C++中，你不能直接将析构函数声明为纯虚函数（`virtual ~ClassName() = 0;` 这样的语法是不合法的）。析构函数可以被声明为虚函数，但不能被声明为纯虚函数，因为析构函数需要有一个实现体（即使它只包含`{}`），以便在对象销毁时调用。
* 通过在基类中提供一个带有虚析构函数的声明（并且提供一个空的实现体），然后在派生类中提供具体的析构函数实现，来解决销毁派生类对象时先调用派生类析构再调用基类析构的问题。这是多态性在析构过程中的体现。

```c++
class A{
public:
	virtual void test() = 0;
    virtual void test() = 0{cout << "纯虚函数也可以在基类中实现"}
	virtual ~A() {cout<< "空函数体" << endl;} //析构函数：必须在父类中也添加虚析构函数
};
A::~A(){
	delete p;
}
class B:public A{
public:
   void test() override{
       cout << "这是重写" << endl;
   }
   ~B() override { // 重写析构函数  
        // 派生类特有的析构逻辑  
        std::cout << "B destructor called" << std::endl;  
    }
}
//
//创建抽象类指针指向派生类对象
B b;
A *a = &b;
a->test();
//创建抽象类引用指向派生类对象
B b;
A &a = b;
a->test();
```

纯虚析构的本质:

* 纯虚析构函数的存在主要是为了**确保通过基类指针删除派生类对象时，能够调用到派生类的析构函数**。
* 必须为纯虚析构函数提供一个函数体，因为当前类的析构释放必须由当前类的析构函数决定。
* 纯虚析构函数必须有**有代码实现**。

纯虚函数：

* 纯虚函数也必须重写
* 抽象类可以创建抽象类指针或者引用指向派生类对象
* 基类的纯虚函数也可以实现



### 10.3.7 静态类型和动态类型，静态绑定和动态绑定

* 静态类型：静态类型是指在**编译时已确定**每一个变量的类型，是对象在声明时**明确指定的类型**，不会在运行时改变。
* 动态类型：是在**运行期**时根据变量的实际值来确定其类型，通常是指一个指针或引用目前所指对象的类型。
* 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型。在**编译期**就确定调用哪个函数或方法，主要适用于静态方法和非虚函数，编译器会根据函数或方法的名称和参数类型来确定调用方式
* 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型。根据对象的实际类型来决定调用哪个函数。这意味着在**运行时**才能确定调用哪个函数或方法。这主要适用于虚函数和多态。

```c++
class A{
public:
	/*virtual*/ void func(){}
};
class B:public A{
public:
	void func(){}
}
class C:public B{
public:
	void func(){}
}
C *pc = new C(); //pc的静态类型是它声明的类型C*，动态类型也是C*
B* pb = new B(); //pb的静态类型和动态类型都是B*
A *pa = pc;  //pa的静态类型是A*，动态类型是pa所指向的对象pc的类型C*
pa = pb; //pa的静态类型是A*，但是动态类型更改了，现在是B*
C *pull = nullptr; //pull的静态类型是其声明的类型C*，没有动态类型
pa->func(); //B::func()父类是虚函数，pa的静态类型永远是A*，动态类型是B*
pc->func(); //c::func() 静态与动态类型都是C*

pull->func(); //基类A加了func(重写)，显示空指针异常，因为func是虚函数，动态绑定时，在运行时调用func()发现pull是空指针。
		//不加virtual时(隐藏),C::func() 空指针也可以调用函数，因为这是在编译期就确定了（静态绑定），和指针是否为空没有关系。
```

* 基类A中的func如果不是虚函数，那么无论pa、pb、pc指向那个子类对象，对func的调用都是在定义pa、pb、pc时的**静态类型决定，早已在编译期就去确定了**
* 同样的**空指针也能调用非虚函数而不报错**，因此静态绑定不能实现多态。
* 如果func是虚函数，所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定有性能损失，但是能实现多态绑定。

### 10.3.8、静态绑定和动态绑定的区别

* 静态绑定发生在编译期，动态绑定发生在运行期
* 对象的动态类型可以更改，但是静态类型无法更改；
* 想实现多态，必须用动态绑定
* 在继承中除了虚函数是动态绑定，其他都是静态绑定

```c++
class MyClass {  
public:  
    void myFunction() {  
        std::cout << "MyClass::myFunction()" << std::endl;  
    }  
};  
  
int main() {  
    MyClass obj;  
    obj.myFunction(); // 编译器在编译期就能确定调用的是MyClass::myFunction  
    return 0;  
}
```



### 10.3.9、类中如何实现只静态分配和只动态分配

* 实现**只静态分配**可以**把new、delete运算符重载为private属性**，**只动态分配**可以**把构造和析构设置protected属性**，在用子类来动态创建。
* 建立类的对象有两种方式：
	* 静态建立：静态建立一个对象。由编译器为对象在栈空间中分配内存
	* 动态建立：A *a = new A();，利用new运算符为对象在堆中分配内存。
* 只有new运算符可以把对象创建在堆上，所以限制new运算符，设为private，就可以实现类对象只能建立在栈上。



## 10.4、静态多态

C++也支持一种称为静态多态（也称为编译时多态）的特性，这主要通过模板、函数重载和运算符重载来实现。静态多态的原理在C++中主要体现在**函数重载和运算符重载**上，这些机制**允许在编译时根据函数的参数类型、数量或顺序来确定调用哪个具体的函数或运算符**。

**静态多态的实现方式**：

1. **模板（Templates）**：
	模板是C++中实现泛型编程的一种机制。通过使用模板，我们可以编写与类型无关的代码。编译器在编译时根据提供的类型信息生成特定类型的代码。这种方式的多态性是在编译时确定的，因此被称为静态多态。

	```cpp
	template<typename T>  
	T max(T a, T b) {  
	    return (a > b) ? a : b;  
	}  
	 
	int main() {  
	    int i = 5, j = 10;  
	    double x = 1.5, y = 2.5;  
	    std::cout << "Max(i, j): " << max(i, j) << std::endl;  
	    std::cout << "Max(x, y): " << max(x, y) << std::endl;  
	    return 0;  
	}
	```

2. **函数重载（Function Overloading）**：
	函数重载允许在同一个作用域内定义多个同名函数，只要它们的参数列表（参数的数量、类型或顺序）不同即可。编译器在编译时根据函数调用时提供的参数类型来确定应该调用哪个函数。这也是一种静态多态。

	编译器在编译时通过以下步骤来确定调用哪个函数：

	* **预处理**：把头文件当中的函数声明拷贝到源文件，避免编译过程中的语法分析找不到函数定义。

	* **编译**：进行语法分析，同时进行符号汇总（包括函数名）。

	* **汇编**：生成函数名到函数地址的映射，这一步涉及到函数名的修饰（Name Mangling），即编译器会将函数名和参数类型等信息组合成一个唯一的修饰名，以便在链接时区分不同的函数。

	* **连接**：将多个文件中的符号表进行汇总合并，通过修饰名找到正确的函数地址。

	函数重载的底层实现依赖于函数名修饰规则，这些规则确保了即使函数名相同，但由于参数列表不同，编译器也能生成不同的修饰名，从而在链接时区分它们。

	```cpp
	void print(int i) {  
	    std::cout << "Printing int: " << i << std::endl;  
	}  
	 
	void print(double f) {  
	    std::cout << "Printing float: " << f << std::endl;  
	}  
	 
	int main() {  
	    print(7); // Calls print(int)  
	    print(7.0); // Calls print(double)  
	    return 0;  
	}
	```

3. **运算符重载（Operator Overloading）**：
	运算符重载允许为已有的运算符赋予多重含义，即同一个运算符作用于不同类型的数据时可以有不同的行为。这也是在编译时根据操作数的类型来决定的，因此也是静态多态的一种形式。

	运算符重载的实现方式主要有两种：**成员函数重载和友元函数重载**。

	* **成员函数重载**：运算符作为类的成员函数实现时，左侧操作数必须是该类的对象（或该类的派生类对象），而右侧操作数可以是任意类型（取决于函数参数的类型）。
	* **友元函数重载**：运算符作为友元函数实现时，可以访问类的私有成员，且左右操作数的类型可以更灵活。

	运算符重载的原理与函数重载类似，也是通过函数名修饰规则来区分不同的运算符函数。在调用重载的运算符时，编译器会根据操作数的类型和数量来确定调用哪个具体的运算符函数。

	```cpp
	class Vector {  
	public:  
	    Vector(int s) : size(s) {}  
	    Vector& operator=(const Vector& other) {  
	        // 实现赋值运算符  
	        return *this;  
	    }  
	 
	    // 假设还有其他成员...  
	 
	private:  
	    int size;  
	};  
	 
	int main() {  
	    Vector v1(10);  
	    Vector v2(20);  
	    v1 = v2; // 调用重载的赋值运算符  
	    return 0;  
	}
	```

**总结**

在C++中，静态多态主要通过模板、函数重载和运算符重载来实现。这些机制允许在编译时根据类型信息选择正确的函数或模板实例，从而提供了类型安全且高效的代码复用方式。与动态多态（通过虚函数实现）相比，静态多态在编译时就能确定行为，因此通常具有更好的性能。







## 10.5 、类型转换

![image-20240415093505105](全栈_C++.assets/image-20240415093505105.png)

### **10.5.1、RTTI运行时类型识别：**

* 向下类型转换（基类指针转换为派生类指针）不会自动进行，因为一个基类对应好多派生类，所以**向下类型转换必须加动态类型识别技术**，RTTI技术，用dynamic_cast进行向下类型转换。
* 是C++语言的一个特性，它允许程序在运行时查询对象的实际类型。
* RTTI提供了两个主要的运算符：`dynamic_cast`和`typeid`，以及`type_info`类，它们一起工作以在运行时确定对象的类型。
* 运行阶段类型识别（RTTI）**为程序在运行阶段确定对象的类型**，**保证安全的类型转换**，只适用于包含虚函数的类，即继承层次结构中的多态对象

#### **dynamic_cast**

* dynamic_cast运算符**只能转换具有继承关系的指针或者引用**。

  * 由父类型转换为子类型（**基类必须包含虚函数**）
  
* **不能转换基础数据类型，不能转换非继承关系的指针和引用**

* 转换前会进行**运行时检查转换是否有效**，子类指针可以转换为父类指针，类型安全父类型转换为子类型（基类必须包含虚函数）

  * dynamic_cast向下转换**只适用于包含虚函数的类**，因为运行时类型信息存储在虚表中，没有虚表无法使用dynamic_cast。
  * dynamic_cast 可以将派生类指针转换为基类指针，这种画蛇添足的做法没有意义。
  * dynamic_cast 可以用于引用，但是，没有与空指针对应的引用值（引用的目标不能是空指针），如果转换请求不正确，会出现 bad_cast 异常。
  	* 如果转换无法进行（比如基类指针不指向派生类对象），它会**返回空指针（对于指针类型）**或者**抛出`std::bad_cast`异常（对于引用类型）**
  
  **语法：**派生类指针 = dynamic_cast<派生类类型 *>(基类指针);
  
  基类指针可以调用派生类对象，如何知道基类指针所指向的是那种派生类的对象呢？

```c++
class person{
public:
    virtual void test(){}
    virtual void test1(){}
    virtual void test3(){}
    virtual ~person(){}
}
class student:public person{
public:
	void test() override { cout << "章建雄大二比";}
    void test1() override {cout << "章建雄是我儿";}
}
person *p; //父类指针
student *ps = (student *)p; //c风格的强制转换，可以将基类指针p赋值给派生类指针ps,程序员必须保证目标类型正确
student *ps = dynamic_cast<student>(p); //将基类指针转换为派生类指针
if(ps!=nullptr){
    ps->test();
}
delete p;
```

#### type-id

* `typeid`运算符用于在运行时获取对象的实际类型。它返回一个对`type_info`对象的引用，该对象封装了有关类型的信息。

```c++
Base* basePtr = new Derived;  
const type_info& type = typeid(*basePtr);  
cout << "Type is: " << type.name() << endl;
```

#### type_info

* `type_info`是一个标准库类，它封装了有关类型的信息。你通常不会直接创建`type_info`对象，而是通过`typeid`运算符获取它们的引用。`type_info`类提供了一些成员函数来比较类型信息（如`operator==`和`before`），以及获取类型的名称（如`name`）。



### 10.5.2、static_cast

```c++
staitc_cast<T>(expression)
```

* 用于非多态类型的转换
	* 基础数据类型的转换，具有继承关系的指针或者引用（不涉及虚函数的类）
	* **不能转换基础类型指针，不能转换类对象指针**
* **不会进行运行时检查**

```c++
double d = 3.14;
int i = static_cast<double>(d);
class student{}
class child:public student{}
student *p = NULL;
child *ptr = static_cast<child *>(p); //父指针转子指针(不涉及虚函数)
child *p1 = NULL;
student *ptr1 = static_cast<student *>(p1); //子类指针转换父类指针
student stu;
student &stu_t = stu; //父类引用
child &chi = tatic_cast<child>(stu_t); //父类引用转换为子类引用，子类引用也可以转换为父类引用
```



**疑问：static_cast也可以用于基类和子类的转换，为什么还需要dynamic_cast**？

* 子类转父类是安全的（向上转换），不需要static_cast和dynamic_cast。
* static_cast在编译时进行类型检查，但是不提供运行时类型检查，这意味着即使基类指针不指向派生类对象，static_cast也会指向转换。
* dynamic_cast提供了运行时类型检查，确保只有基类指针实际指向派生类对象时才会执行转换。

```c++
class Base{
public:
	virtual ~Base();
	virtual void doSmething(){}
};
class derived:Base{
	~derived();
	void doSmething() override{}
};
//向上转换是安全的
derived *de_ptr;
Base *ptr = &de_ptr;
//向下转化:将Base对象转换为derived对象
Base *ptr = new Base();		// dynamic_cast转换会报错，因为父类指针不指向子类对象，而dynamic_cast会RTTI
Base *ptr = new derived(); 	//	会转换成功，父类指针实际指向子类对象
derived *de_ptr = dynamic_cast<derived *>(ptr);  // 转换
```



### 10.5.3、const_cast

* `const_cast`用于**添加或移除类型的`const`或`volatile`限定符**
	* 这里的修改不是修改之前的变量，而是创建一个新变量指向同一块内存。
* 主要用于修改指向`const`对象的指针或引用，以便能够修改该对象
* 可以进行基础类型的转换

```c++
const int a = 10; 
int* p = const_cast<int*>(&a); // 移除const限定符，但修改*p是未定义行为
const int &b = a;
int &c = const_cast<int>(b);
c = 20; //此时c、b、a都是20，因为全部指向同一块内存。
const int *p = nullptr;
int *p2 = const_cast<int*>(p); //移除const
int *p = nullptr;
const int *p2 = const_cast<const int *>(p); //增加const
```



### 10.5.4、reinterpret_cast

* 强制类型转换，只能转换指针
* 提供了一种低级别的转换机制，它重新解释给定的位模式。
* 几乎不做任何类型检查
* 常用于硬件操作、将整数转换为指针、以及处理函数指针等场景

```c++
int i = 12345;  
char* p = reinterpret_cast<char*>(&i); // 将int*转换为char*
class person{}
class student{}
person *per = NULL;
student *stu = reinterpret_cast<student*>(per); //强制转换不相关的对象指针

typedef void (*FUNC)(int,int);
typedef int(*FUNC2)(int, char*);
FUNC func;  //函数指针
FUNC2 func2= reinterpret_cast<FUNC2>(func);
```





## 10.6、继承机制中的对象之间如何转换、指针和引用之间如何让转换

* **向上转换型**
	* 将派生类的指针或引用转换为基类的指针或引用，这是自动进行的，而且向上转换时是类型安全的。
* **向下转换型**
	* 将基类的指针或引用转换为派生类类的指针或引用，由于一个基类可能对应很多派生类，所以转换不会自动进行，而且向下类型转换必须加动态类型识别技术。
	* RTTI，dynamic_cast

```c++
class person{
    virtual test(){}
};
class student:public person{};
student stu;
person *per = &stu;  //向上类型转化
person *p = new student();
student *stu1 = dynamic_cast<student>(p) //向下类型转换
```





# 11、构造与析构

## **11.1、构造函数与析构函数**

特殊函数：由**系统自动执行**，在程序中**不可显式的调用**。

* **构造函数**：建立对象时，对对象的数据成员进行初始化。
	* 与类同名
	* 没有返回值，不需要类型
	* 默认构造函数是无参的，无函数体的，显式定义的话，编译器就不再自动生成
	* 可以被重载，可以有多个，可以定义多个参数与参数类型不同的构造函数。
	* **定义对象的同时，构造函数被自动调用**。在建立对象时系统会为对象分配内存空间，此时先执行构造函数，就把指定的初值送到对应成员变量的存储单元中。
	* 构造函数中对于内置类型是不做处理的，对于自定义类型会调用其构造函数！
		* 内置类型：字符，整型，浮点数等
		* 自定义类型：struct、class等
* **析构函数**：对象的声明周期结束时回收对象，撤销对象的。
	* 与类同名
	* 没有返回值
	* 只有一个，无参
	* 不能重载，当类存在资源申请的时候就需要些析构函数，否则会造成资源泄露。
	* **静态(static)局部对象**在函数调用结束，对象并不会释放掉，当main函数结束或者调用exit函数结束程序时，才会调用析构函数。
	* 如果定义了一个全局的变量，则在程序的流程离开其作用域时，调用该全局对象的析构函数！
	* 当用new建立对象时，当用delete运算符释放该对象时先调用析构函数，再调用operator delete库函数释放内存！
	* 对于析构函数对于内置类型在销毁时系统会自动回收内存，而对于自定义类型会调用其析构函数！
* **不同对象的调用顺序**：
	* **先构造的后析构，后构造的先析构**。
		* 例如父类和子类的继承关系
	* 如果**在全局范围定义对象**，那么它的构造函数在本文件模块中的所有函数执行之前调用。
	* 如果一个程序包含多个文件，那么它的构造函数的调用顺序是不确定的，当main函数结束或者调用exit结束程序时，调用析构函数！
	* 如果定义局部对象，那么定义时自动调用构造函数，函数调用结束时，调用析构函数！
	* 如果定义**静态(static)函数**，则只在程序调用的第一次调用构造函数（只初始化一次），当main函数结束时或者调用exit函数时调用析构函数！

**构造函数和析构函数的调用时机**：

* **构造函数**
	* 对象实例化
	* 对象拷贝：使用已经创建的对象去初始化另一个对象
	* 列表初始化
	* 值传递或者返回时：当对象作为值传递给函数，或者从函数作为值返回时，会创建临时对象，并调用相应的构造函数（可能是复制构造函数、移动构造函数，或者是其他重载的构造函数）。
* **析构函数：**
	* 对象生命周期结束时：对象离开其作用域
	* 对象被销毁时
	* 程序结束时：所有的全局对象和静态对象的析构函数都会被调用，

**problem：**

**构造函数和析构函数可以恶抛异常吗？**

都不可以，应该保证对对象的正常构造和对资源的释放，不应该终止下来。

* 构造函数应该避免抛出异常
	* 构造函数抛出异常后，后面的构造将不会执行，对象的析构将不会被执行。
	* 构造函数抛出异常时，本应该在析构函数中被delete的对象没有被delete，会导致内存泄露
	* 当对象发生部分构造时，已经构造完毕的子对象(非动态分配)将会逆序地被析构。
* 析构函数不应该抛出异常
	* 其他程序正常，仅析构异常：那么当析构抛出异常，则异常点之后的程序都不会执行，如果析构函数在异常点之后执行了某些必要的动作如释放某些资源，则这些动作将不会被执行，造成内存泄漏
	* 其他程序异常，且析构异常：通常异常发生时，C++机制会调用已经构造过的对象的析构函数来释放资源，若此时析构也异常了，则前一个异常还没处理，又有新的异常，或造成程序崩溃。

**析构异常了怎么办？**

* 若析构函数抛出异常，调用std::abort()来终止程序
* 在析构函数中catch捕获异常并作处理，吞下异常；
* 如果客户需要对某个操作函数运行期间抛出的异常做出反应，class应该提供普通函数执行该操作，而非在析构函数中。

![image-20240330161109723](全栈_C++.assets/image-20240330161109723.png)







## 11.2 、C++的所有构造函数

※左值：能取地址的值；右值：没办法取地址的值。

* 默认构造函数
* 初始化构造函数（有参）
* 拷贝构造函数(左值引用&)
* 移动构造函数（move和右值引用&&）

* 委托构造函数
* 转换构造函数

```c++
class Student{
public:
    int age;
    int num;
public:
    Student(){ //默认构造函数
        this->age = 18;
        this->num = 110;
    }
    Student(int b):	Student(18,110){} //委托构造函数
    Student(int a,int b):age(a),num(b){} //初始化构造函数 -->同时作为委托的代理构造函数
    
    Student(const Student &S){ //拷贝构造函数
		this->age = S.age;
        this->num = S.age;
    }
    Student &operator=(const Student &stu){ //拷贝重载运算符，当输入参数为左值时，调用拷贝重载运算符
		age = stu.age;
        num = stu.num;
        return *this;
    }
    
    Student(const Student &&s) noexcept{ //移动构造函数->右值引用
										//移动构造函数一般不应该抛出异常，因为原则上它不应该申领任何资源
    }
    Student &operator=(Student &&s) noexcept{//当输入参数为右值时，调用移动赋值运算符
			if(this == &a)
                return *this;
        	age = std::move(s.age);
        	num = std::move(s.num);
        	return *this;
    }
    Student(int r){ //转换构造函数->单参，且参数类型不同，需要转换
        this->age = r;
        this->num = 11000;
    }
    ~Student(){}
}

    Stirng s = "hello world"; //拷贝初始化
    vector<string> v;
    v.push_back(str);  //调用常用的拷贝构造
	v.push_back(move(str)); //调用移动构造函数

struct person{
	string name;
	int age;
	person(string m_name,int m_age):name(m_name),age(m_age){}  //初始构造函数
	person(const person &other):name(move(other.name)),age(move(other.age)){}  //拷贝构造函数
	person(person && other):name(move(other.name)),age(move(other.age)) noexcept{} //移动构造函数
};
```



## 11.3 、移动构造函数

**移动构造函数**（move和右值引用&&）

**移动语义**(std::move)：将**其他对象（通常为临时对象）拥有的内存资源“移为己用”**；

* move()能把**左值强制转换为右值,用以实现移动语义**
* move是将对象的状态或者所有权从一个对象转移到另一个对象，**只是转移，没有内存的搬迁或者内存拷贝**，因此转移所有权效率比较高。
	* 移动构造函数被声明为接受一个同类型的右值引用（`T&&`）作为参数，并且通常会将其参数的资源“窃取”到当前对象中，然后将参数设置为一个安全但不可用的状态（通常是空状态或指向已释放的资源）。

**移动构造函数：从一个临时对象（右值）转移资源（如内存、文件句柄等）到另一个对象，而不是复制这些资源。**

* 将对象A的所有权转移给对象B
* 对于同一块内存，原来用来存放对象A，发生对象移动后，用来存放对象B
* 发生对象移动后，原有的对象A将不再被使用。
	* 和拷贝赋值运算符一样，移动构造函数也是二元运算符"operator="的重载，它只能被定义为类的成员函数，不能被定义为普通函数
	* 移动构造函数在构造对象的时候**避免了拷贝一个新的对象**，**只是浅拷贝指针**。
		* 浅拷贝的危险之处就在于两个指针指向同一片空间，为了防止旧指针释放内存空间，可以**置空旧指针**。
	* 移动构造函数**可以重复利用原有的内存空间，提供了代码效率**
	* 移动构造函数的**形参是(&&)右值引用或者将亡值的引用**，而不是(&)左值引用。
		* 亡值：当右值完成初始化或赋值的任务后，它的资源已经移动给了其他对象，这时这个右值就变成了所谓的“亡值”。
	* 当一个对象发生移动以后，**不会自主销毁**，我们可以在移动构造函数的代码逻辑中**显式地让该对象被析构**。

```c++
class Foo{
public:
    Foo() = default;
    ~Foo() = default;
    Foo(const Foo& foo) = default;
    Foo(Foo&& foo) noexcept{
        std::cout << "Foo(Foo&&)\n";
    }
    Foo& operator=(Foo&&) noexcept = default;
    Foo& operator=(const Foo&) = default;
};

void f(Foo foo){
    (void) foo;
}

Foo g() {
    Foo f;
    return f;
}

int main() {
    Foo f1,f2;
    Foo dst(std::move(f1)); // 调用移动构造函数
    Foo dst2 = std::move(f1); // 调用移动构造函数
    f(std::move(dst2)); // 调用移动构造函数
    // 由于rvo的存在，并不会调用拷贝或者移动构造函数
    // 如果把rvo关掉-fno-elide-constructors，在没有移动构造函数的情况下会调用拷贝构造函数
    Foo f = g(); 
    return 0;
}

class MyClass {  
private:  
    int* data;  
    size_t size;  
  
public:  
    MyClass(size_t n) : size(n), data(new int[n]) {  
        // 初始化数据...  
    }  
  
    // 移动构造函数，标记为noexcept  
    MyClass(MyClass&& other) noexcept : size(other.size), data(other.data) {  
        other.data = nullptr;  
        other.size = 0;  
    }  
  
    // 移动赋值运算符，标记为noexcept  
    MyClass& operator=(MyClass&& other) noexcept {  
        if (this != &other) {  
            delete[] data;  
            size = other.size;  
            data = other.data;  
            other.data = nullptr;  
            other.size = 0;  
        }  
        return *this;  
    }  
  
    // 析构函数...  
    ~MyClass() {  
        delete[] data;  
    }  
  
    // 禁用拷贝构造函数和拷贝赋值运算符...  
    MyClass(const MyClass&) = delete;  
    MyClass& operator=(const MyClass&) = delete;  
};

int main(){
    MyClass ret1(18,20);
    MyClass ret2(std::move(ret1)); //调用移动构造函数
    ret2 = std::move(ret1); //赋值运算符
}
```

**移动构造函数的调用：**

* 初始化:T a = move(b); b的类型是T;
* 函数实参传递:f(std::move(a));a的类型是T，f是 Ret(T t);
* 函数返回:在像 T f() 这样的函数中的 return a;，其中 a 的类型是 `T`，且 `T` 有移动构造函数。

**构造函数之间的区别：**

* 移动构造函数的参数是右值引用，拷贝构造函数是左值引用
	* noexcept是为了防止在移动构造函数转移资源时，因为出现异常而导致资源还没转移完就中断了。

**移动构造函数的目的：**

* 但我们用对象a初始化对象b后，对象a就不再使用了，但是在析构之前对象a的空间还存在，拷贝构造函数是将a对象的内容复制一份到a中，那么为什么不**直接用对象a的空间**呢？
* 拷贝构造函数对于指针是深复制，而**移动构造函数对于指针是浅复制**，而浅拷贝会导致了两个指针共同指向同一片内存空间，若第一个指针将其释放，另一个指针就不合法了。为了避免第一个指针释放空间，需要将其置空，这样调用析构的时候，有判断为NULL的语句，所以析构a并不会回收a->value指向的空间。




## 11.4 、委托构造函数

**需求：**

​		有的程序需要构造很多构造函数，对于特定的成员变量每个构造函数都得初始化，会造成代码冗余。

​		类的构造函数可以在初始化列表的位置调用该类的另一个构造函数，这个构造函数就叫委托构造函数，其将构造对象的工作委托给了另一个构造函数,另一个构造函数成为代理构造函数。所以初始化时会先执行代理构造函数的函数构造，在执行委托构造函数的函数体。

```c++
class Student{
private:
    int age;
    string name;
    void comminit(){}
public:
    Student():Student(18,"wang"){} //委托构造函数
    Student(int m_age):Student(20,"zhang"){}  //委托构造函数
    Student(string m_name):Student(30,"jiang"){}  //委托构造函数
    Student(int m_age,string m_name):age(m_age),name(m_name){comminit();}  //代理构造函数
}
```

* 每个构造函数都可以委托另一个构造函数为代理
* 不要递归循环委托
* 委托构造函数的执行顺序是先执行代理构造函数的初始化列表，然后执行代理构造函数的主体，最后执行委托构造函数的主体
* 如果在代理构造函数执行完成后，委托构造函数主体抛出了异常，则自动调用该类型的析构函数
* 如果一个构造函数为委托构造函数，那么其初始化列表里就不能对数据成员和基类进行初始化

**代理构造函数模板：**

![image-20240330163408054](全栈_C++.assets/image-20240330163408054.png)





## **11.5、深拷贝与浅拷贝**

**浅拷贝**：通过拷贝构造函数实现的，当程序员不主动的编写拷贝构造函数和重载赋值函数，编译器会以浅拷贝的方式自动生成这些函数，但是**只复制指向某个对象的指针**，将此对象的地址给新的对象，并**不会创建一片新的内存**，**新旧对象共享一块内存**。

* 浅拷贝只复制对象的成员变量值，而不复制动态分配的资源或指针所指向的数据
* 当成员变量
	* 新对象的内存没释放，造成**内存泄漏**
	*  新旧对象指向了同一块内存，**任何一方的值改变都会修改另一方的值**
	* **在对象被析构时，空间被释放了两次**

**深拷贝**：需要**手动的编写拷贝构造函数与赋值运算符**，**会开辟一片新的空间存放数据**（new），**不共享内存**，修改新对象，旧对象保持不变。

深拷贝不仅复制对象本身（包括其所有成员变量），还**递归地复制**对象内部所有指向动态分配内存的指针所指向的数据，直到所有被引用的数据都是基本数据类型（如`int`、`float`等）或不可变类型（在C++中，基本数据类型通常都被视为不可变的，但如果你指的是像`std::string`这样的封装了动态内存管理的类，则它们的行为类似于可变类型，但在深拷贝时，你会复制整个字符串内容）。

* 一个对象以值传递的方式传入函数体
* 一个对象以值传递的方式从函数体返回
* 一个对象需要通过另一个对象进行初始化

**使用时机：**

* **浅拷贝：**
	* 当对象中的成员变量不包含指针或动态分配的资源时，通常可以使用浅拷贝。
* **深拷贝：**
	* 当对象中包含指针或动态分配的资源时，通常需要使用深拷贝。
	* 如果类显示的写了析构函数，通常需要深拷贝，以确保每个对象拥有自己的资源副本，并在对象生命周期结束时正确地释放资源。

深拷贝和浅拷贝的概念主要适用于包含动态分配内存或指针的对象。

浅拷贝：

```c++
#include <iostream>  
#include <cstring> // 用于strcpy  
  
class ShallowCopyExample {  
public:  
    char* data;  
  
    // 构造函数  
    ShallowCopyExample(const char* str) {  
        data = new char[strlen(str) + 1];  
        strcpy(data, str);  
    }  
  
    // 拷贝构造函数（浅拷贝）  
    ShallowCopyExample(const ShallowCopyExample& other) {  
        data = other.data; // 浅拷贝：直接复制指针  
    }  
  
    // 析构函数  
    ~ShallowCopyExample() {  
        delete[] data;  
    }  
  
    // 其他成员函数...  
    void print() const {  
        std::cout << data << std::endl;  
    }  
};  
  
int main() {  
    ShallowCopyExample obj1("Hello");  
    ShallowCopyExample obj2 = obj1; // 使用浅拷贝的拷贝构造函数  
  
    obj2.data[0] = 'J'; // 修改obj2的数据  
    obj1.print(); // 输出: Jello，因为obj1和obj2共享同一块内存  
    obj2.print(); // 输出: Jello  
  
    // 注意：这里存在内存泄漏和双重释放的风险，因为两个对象都试图删除同一块内存  
    // 为了避免这个问题，通常不建议实现浅拷贝的拷贝构造函数  
}
```

深拷贝：

```c++
class DeepCopyExample {  
public:  
    char* data;  
  
    // 构造函数  
    DeepCopyExample(const char* str) {  
        data = new char[strlen(str) + 1];  
        strcpy(data, str);  
    }  
  
    // 拷贝构造函数（深拷贝）  
    DeepCopyExample(const DeepCopyExample& other) {  
        data = new char[strlen(other.data) + 1]; // 分配新内存 ，递归复制char类型 
        strcpy(data, other.data); // 复制数据  
    }  
  
    // 析构函数  
    ~DeepCopyExample() {  
        delete[] data;  
    }  
  
    // 赋值运算符重载（也需要实现深拷贝）  
    DeepCopyExample& operator=(const DeepCopyExample& other) {  
        if (this != &other) { // 自赋值检查  
            delete[] data; // 释放旧内存  
            data = new char[strlen(other.data) + 1]; // 分配新内存  
            strcpy(data, other.data); // 复制数据  
        }  
        return *this;  
    }  
  
    // 其他成员函数...  
    void print() const {  
        std::cout << data << std::endl;  
    }  
};  
  
int main() {  
    DeepCopyExample obj1("Hello");  
    DeepCopyExample obj2 = obj1; // 使用深拷贝的拷贝构造函数  
  
    obj2.data[0] = 'J'; // 修改obj2的数据  
    obj1.print(); // 输出: Hello，因为obj1和obj2拥有独立的内存  
    obj2.print(); // 输出: Jello  
  
    // 这里没有内存泄漏或双重释放的风险  
}
```



## **11.6、拷贝构造函数**

**概念：**

​	拷贝构造函数(复制构造函数)的基本写法：（单形参列表）

```c++
Foo(FOO &S)
Foo(const Foo&S) //最常用的写法
Foo(const volatile &s);
Foo(volatile &s);
```

​	在建立对象时可用**同一类的另一个对象来初始化该对象的存储空间**，这是所用的构造函数称为拷贝构造函数。

**需求**：

* 当类成员没有指针成员的时候其实是可以不用编写拷贝构造函数的，利用ObjA = ObjB来赋值是没有问题的。
* 但是当有**指针成员**，用来存放动态申请的字符串的地址，在类中使用new方法动态申请内存并让指针指向该空间，再进行简单的类对象赋值（ObjA = ObjB）之后，两个对象的指针将同时指向那片内存空间，这样很有可能会导致同一块内存释放两次。
* 使用拷贝构造函数，先申请指针所指向的内存空间，再将空间的内容拷贝（所以使用&）过来，这样各自指向各自的空间。

* 拷贝构造函数的参数是**引用**，一般加const，防止修改原本的对象数据。如果把一个真实的类对象作为参数	传递到拷贝构造函数，会引起无穷递归 。
* 拷贝构造函数再不显式定义的情况下，编译器会自动构造一个缺省的拷贝构造函数。

```c++
class Person{
public:
	int age;
	Person(){} //无参构造
	Person(int age){//有参构造
		this.age = age;
	} 
	Person(const Person &p){  //拷贝构造函数
		age  = p.age;  //这里是浅拷贝，默认的拷贝构造便会进行值拷贝,因为这里不涉及指针
	}
};

Person p; //匿名
Person p(18); //传递的是int类型的值，对应有参构造，
Person P2(p); //调用拷贝构造，传递的是类对象-->初始化新的对象
Person p = 10; //隐式法
```

编译器默认添加的三个函数：构造函数（空实现）、析构函数（空实现）、拷贝构造（值拷贝），即使已经写了有参构造函数，编译器不在提供默认构造函数，仍会提供拷贝构造函数。

**拷贝构造函数的调用时机**：

提供同类型的实参就能调用。

* 已经创建好的对象来初始化新的对象；
* 值传递的方式给函数参数传值（非引用情况下）；值传递的本质就是调用拷贝构造函数，创建一个新的对象。
* 函数的参数是类对象时

```c++
void dowork(Person p){  //这里相当于创建了一个新的临时对象   
} 
void test(){
	Person p1(100);
    dowork(p1);   //调用拷贝构造-->值传递的方式给函数参数传值
}
```

* 以值返回的方式返回局部对象
	* 对于此类情况，只会发生在windows系统，在linux系统下，这样并不会调用拷贝构造函数


```c++
Person dowork2(){ //这里返回的是值，不能返回引用，引用在函数调用完成会被释放掉
	Person p;
    return p; //以值方式 返回局部对象，return时这里相当于临时创建并拷贝了一个新的匿名对象，是没有名称的
}
void test1(){
	person p = dowork2(); //可以认为将新的对象拷贝给p，名称变为p，声明周期也就成了p的生命周期
}							//函数执行完成先析构局部对象，再析构临时对象
```



**拷贝赋值运算符：**对类对象进行赋值

基础拷贝赋值运算符：

```c++
Class A{
    A& operator=(A a){
        //xxx
        return *this;
    }
    A& operator=(A &a){
        //xxx
        return *this;
    }
	A& operator  = (const A &a){  //最常用
		// xxxx
		return *this;
	}
    A& operator=(const volatile A &a){
        //xxx
        return *this;
    }
    A& operator=(volatile A &a){
        //xxx
        return *this
    }
};
```

* 拷贝[赋值运算符](https://so.csdn.net/so/search?q=赋值运算符&spm=1001.2101.3001.7020)是二元运算符"operator="的重载，它只能被定义为类的成员函数，不能被定义为普通函数。
* 拷贝赋值运算符**把右操作数的成员数据拷贝给左操作数的成员**。
* 为了避免对象在拷贝过程中的不必要的复制，拷贝赋值运算符**返回类型为引用类型**,。
* 拷贝赋值运算符运行结束通常返回**当前对象的引用（`*this`）**，以**支持链式赋值**（如 `a = b = c`）
* 拷贝赋值运算符的使用场景和拷贝构造函数不一样，如果对一个已经构造过的对象进行拷贝赋值，则此时并不会调用拷贝构造函数，而是调用拷贝赋值运算符。
* 在重载赋值运算符的时候，也可以让拷贝赋值运算符复制不同类型的对象，只需要在重载的函数内部增加相应的类型转换逻辑即可实现。
* 当没有自定义的移动构造函数、移动赋值运算符、拷贝赋值运算符时，编译器会自动生成一个**inline public隐式拷贝赋值运算符**；

**为什么要使用拷贝赋值运算符：**

​		用户在使用语句ObjB = ObjA的时候，或许ObjB的pStr已经指向了动态申请的空间，如果直接简单将其指向的地址覆盖，就会导致内存泄露，所以需要对=赋值操作符进行重载，在重载函数中判断pStr如果已经指向了动态申请的空间，就先将其释放。

**拷贝运算符和拷贝构造函数是什么关系**：

* 拷贝构造函数在已经存在的对象上调用，用于更新该对象的状态以匹配另一个对象的状态。在更新之前，如果目标对象之前已经分配了资源，则可能需要先释放这些旧资源

* 拷贝构造函数是在创建新对象时调用的，而拷贝赋值运算符是在已经存在的对象上调用，用于更新其状态以匹配另一个对象的状态。



## **11.7、拷贝初始化和直接初始化**

* 当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：
	* 直接初始化**直接调用于实参匹配的构造函数**；
		* 直接初始化时，构造函数用于直接创建对象，没有临时对象的创建或涉及。
		* 可以调用**任何可用的构造函数**
	* 拷贝初始化**总是调用拷贝构造函数**。拷贝初始化首先适用指定构造函数**创建一个临时对象**，然后拷贝构造函数将那个临时对象拷贝到正在创建的对象。

```c++
1、String s("hello world");  //直接初始化
2、String s2(s); 			//直接初始化
3、String s3 = "hello world"; 	 //拷贝初始化,先将字符串“hello world”创建临时对象，
						   		 //再把临时对象作为参数，使用拷贝构造函数构造S3
4、String s4 = s3;				//拷贝初始化s4，相当于隐式调用拷贝构造函数，而不是调用复制运算符
```

**这里注意：**

* 当拷贝构造函数为private时，3和4便会报错
* 当构造函数被explicit关键字修饰时，拷贝构造函数的隐式调用便会出错。





## **11.8、初始化和赋值的区别**

**初始化**的含义时在**创建对象**时赋予一个初值；

**赋值**是将对象的当前值擦掉，以一个新值代替。

* 对于简单类型（内置类型等）来说，初始化和赋值没有什么区别
* 对于类和复杂类型来说，这两者最主要的区别便是有没有创建新的对象。

```c++
class A{
public:
    int num_1;
    int nunm_2;
public:
    A(int a,int b):num_1(a),num_2(b);
    A(const A &a){}  //拷贝构造函数
    A& operator = (const A &a){ //拷贝复制运算符：是二元运算符“operator=”的重载；
        						//只能定义为类的成员函数，不能定义为普通函数。
        num1 = num1+1;
        num2 = num2+1;
        cout << "重载" << endl;
        return *this;
    };
};
A a(1,2); //直接初始化
A b = a; //拷贝初始化调用拷贝构造函数
A C;
C = a;//赋值操作,对象C已创建，对象a中 num1 = 1，num2 = 2；对象C中num1 = 2,num2 = 2;
A a = new A(); //直接初始化
```

*  拷贝初始化和赋值操作是不同的操作，它们分别涉及到拷贝构造函数和赋值运算符重载。

* 拷贝初始化是在创建对象时从一个已有的对象中初始化新对象，这时候会调用拷贝构造函数来完成初始化。例如：

```c++
cppCopy codeMyClass obj1; // 创建对象
MyClass obj2 = obj1; // 拷贝初始化，调用拷贝构造函数
```

* 在这个例子中，`obj2` 是通过从 `obj1` 中拷贝初始化得到的，这会调用 `MyClass` 类的拷贝构造函数。
* 而赋值操作是在对象已经存在的情况下，将一个已有对象的状态赋值给另一个对象。这时候会调用赋值运算符重载来完成赋值操作。例如：

```c++
cppCopy codeMyClass obj1; // 创建对象
MyClass obj2; // 创建另一个对象
obj2 = obj1;  // 赋值操作，调用赋值运算符重载
```

* 在这个例子中，`obj2` 已经存在，赋值操作将 `obj1` 的状态赋值给 `obj2`，这会调用 `MyClass` 类的赋值运算符重载。
* 因此，尽管拷贝初始化和赋值操作都涉及到对象之间的状态复制，但它们是不同的操作，并且分别调用了拷贝构造函数和赋值运算符重载。







# 12、类

## 12.1、类的成员

**类的成员函数**

* 类的成员函数是类定义的一部分，它们描述了类对象可以执行的操作。
* 成员函数的代码通常存储在程序的**代码段，静态函数也不例外**，**类的数据成员存储在数据段或者堆/栈上**，因此**所有对象实例共享相同的成员函数代码**，而不是每个对象都有自己的函数副本。
* 当成员函数被调用时，编译器会隐式地传递一个指向调用对象的指针（通常称为`this`指针）。这使得成员函数能够访问和修改对象的数据成员。

**类的成员变量：**

* **非静态成员变量**：是对象的一部分，因此它们会被分配在堆内存（如果对象是动态分配的）或栈内存（如果对象是作为函数局部变量创建的）中。每个对象实例都有自己的非静态成员变量的副本。
* **静态成员变量**：静态成员变量与类本身相关联，而不是与类的特定实例相关联。在C++中，静态成员变量通常存储在全局/静态存储区，这取决于它们的初始化方式和链接属性。所有对象实例共享同一个静态成员变量的内存地址。	

​		类的定义本身（包括成员变量和数据类型）并不直接存储在代码区。类的定义提供了如何创建对象以及对象如何行为的说明，但实际的类对象数据（即对象的实例）存储在堆区或栈区，取决于对象的创建方式（使用`new`运算符在堆上创建，或在函数内部作为局部变量在栈上创建）。



## 12.2、this指针

特点：

* 隐式的在每个成员函数中，**只能在成员函数中使用**，全局函数、静态函数都不能使用this。
* 实际上，**成员函数默认第一个参数为（T *const this**）。
	* 因此**this在成员函数的开始前构造，在成员函数的结束后清除**，这个生命周期同任何一个函数的参数是一样的，没有任何区别，当调用一个类的成员函数时，**编译器将类的指针作为函数的this参数传递进去**。
* 指向被调用的成员函数所属的**对象**的首地址。
	* 一个对象的this指针并不属于对象的本身的一部分，不会影响sizeof(对象)的结果，更像是一个指向对象本身的指针，在成员函数被调用时由编译器自动传入。
	* **this指针的存放位置会因编译器不同而会有不同的放置位置**（栈、寄存器、全局变量）。

作用：

* 解决命名冲突
* 作为非静态函数的隐含形参，对类中各成员的访问都可以通过this指针。

```c++
class person{
public:
	int age;
	string m_name;
public:
	person(int age,string name){
        this->age = age;  //当类成员变量和对象的属性命名相同时，this指针避免命名冲突
        m_name = name;
    }
    void func(person &p){  //这里其实this被隐含了，正确的应该是void func(person *this,person &p)
        if(age == p.age)  //if(this->age == p.age)
            return xxx;
    }
    frined person operatpr+(const person &a,const person&b);    
};
    person operator(const person&a,const person &b){  //运算符重载
        return person(a.age + b.age);
    }
    std::ostream poerator<<(std::ostream& os,person &per){
        os << per.age ;
        return os;
    }

void test(){
    person p(18,"wang");
    person p1(18);
    person p2(20);
    person p3 = p1 + p2;
    cout << p3 << endl;
}
```

**this指针是如何找到类实例后的函数：**

* 大多数编译器通过ecx（寄数寄存器）传递this指针，在call指令之前，编译器会把对应的对象地址放到eax中，this指针通过函数参数的首参来进行传递，this指针在函数调用前生成。
* 在类的对象空间中，只有类的数据成员和虚函数指针，不包含代码内容，**调用成员函数时，隐含的传递一个this指针，让成员函数知道是哪个对象在调用它。**
* 类在实例化时，只分配类中的变量空间，并没有为函数分配空间。函数的返回地址、中间变量在栈中，函数代码的二进制形式在.代码区。

**this指针只有在成员函数中才有定义：**

* 因此，当获得一个对象后，也不同通过对象使用this指针，所以无法知道一个对象的this指针的位置，只有在成员函数里才有this指针的位置（&this）。

**每个类编译后，是否创建一个类中函数表保存函数指针，以便来调用函数？**

* 普通的类函数都不会创建一个函数表来保存函数指针，只有虚函数才会被放到虚函数表中
* 通过对象调用一个虚函数时，编译器实际上是通过`this`指针来查找vtable，并**间接地调用**vtable中相应虚函数的地址。这样，如果对象属于一个派生类，并且该派生类重写了基类中的虚函数，那么vptr将指向派生类的vtable，从而实现多态性。
* 而即使是虚函数，如果编译期明确知道调用那个函数（静态绑定），编译器就不会通过函数表中的指针来间接调用，而是直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。

**在成员函数中调用delete this会出现什么问题？对象还可以使用吗？**

* delete this之后，类对象的内存空间会被释放掉，在delete this之后进行的其他函数的调用，只要不涉及this指针的内容，都能正常运行。
* delete this释放了类对象的内存空间，但是内存空间却并不是马上回收到系统中，可能是缓冲或者其他什么原因。此时这段内存是可以访问的，但是其中的值却不确定。
* 如果**在类的析构函数中调用delete this会导致堆栈溢出**，因为delete的本身就会调用析构函数，然后释放内存，当delete之后，析构函数中又调用delete this，形成无线递归析构。造成堆栈溢出。

**this指针调用成员变量时，堆栈会发生什么变化？**

当建立了类的多个对象时，在调用类的成员函数时，你并不知道具体那个对象在调用，此时可以通过查看this指针来查看具体那个对象在调用，**this指针首先入栈，然后成员函数的参数从右向左入栈，然后返回地址入栈**。



## 12.3、类成员的初始化方式

赋值初始化和列表初始化

* **赋值初始化：**
	* 在函数体内部进行初始化
	* **函数体内部的初始化**是在所有数据成员被**分配内存空间后才进行**的
	* 赋值初始化会创建临时对象，临时对象会降低代码效率
* 列表初始化
	* 在构造函数的冒号后面使用初始化列表
	* 初始化列表是**给数据成员分配内存空间时就进行初始化**
	* 初始化顺序是由类的成员声明顺序决定的，而不是初始化列表顺序

**成员列表初始化：**

* 初始化一个**const成员**时
* 初始化一个**引用成员**时
* 当**调用一个基类的构造函数**，而它拥有一组参数
* 当**调用**一个成员类的构造函数，其拥有一组参数。
	* **成员对象**：对象作为类的成员，如果他有构造函数，且构造函数参数不为空，必须使用列表初始化

```c++
class Base{
public:
	const int age;
	int &ref;
public:
	Base(int value):age(value){}  ///引用成员/const成员
	Base(int &ref):ref(ref){}
};

class son:public Base{
 public:
    son(int value,int &ref):Base(age,ref); //调用一个基类的构造函数
    son(int value,int &ref):B(age,ref); //成员对象初始化
private:
    Base B; //成员对象
};
```

**初始化列表比在函数体中赋值快的原因是：**

* 对于自定义类型，成员列表初始化在对象创建时直接调用每个成员变量的构造函数来初始化它们，而函数体内赋值则是先调用默认构造函数创建对象，然后在函数体内对成员变量进行赋值、拷贝、移动等操作。因此，成员列表初始化避免了额外的构造和赋值操0作，提高了初始化的效率。
* 对于内置类型，对象成员变量的初始化发生在进入构造函数之前，列表初始化和函数体赋值初始化没有什么区别



## 12.4、类与类之间的关系

* **继承**
	* 当要实现代码复用时，用继承可以将基类的方法和属性继承过来，同时也可以写新的方法来扩展或者重写基类方法。
	* 继承的缺点：
		* 父类的内部细节对子类是可见的
		* 子类是父类的一种高耦合，当对父类的方法做出了修改的话（比如增加一个参数），则子类的方法必须做出相应的修改（初始化）（多态中子类中**重写**的函数名和形参列表必须和父类一致）。
* **组合**
	* 继承和组合都是为了实现代码复用，其**将对象作为另一个类的成员变量来使用**，从而建立类之间的关系。
	* 当前对象只能通过所包含的那个对象去调用方法，所以所包含的对象的内部细节对当前对象是不可见的。
	* 当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码
	* **类的组合必须使用初始化列表的方式**

```c++
#include <string>

// Composition example
class Engine {
private:
    int horsepower;
public:
    Engine(int hp) : horsepower(hp) {}
    int getHorsepower() const { return horsepower; }
};

class Car {
private:
    std::string make;
    std::string model;
    int year;
    Engine engine; //Engine类对象
public:
    Car(const std::string& make, const std::string& model, int year, int horsepower)
        : make(make), model(model), year(year), engine(horsepower) {}

    void drive() const {
        std::cout << "The " << year << " " << make << " " << model << " is driving with "
            << engine.getHorsepower() <<; //通过对象能调用其类的public成员函数
    }
};
//Engine 类代表了一个引擎，被 Car 类所拥有。
//Car 类拥有一个 Engine 类的实例作为其一部分，实现了组合。
```



## 12.5、阻止类的实例化：

* 将类定义为抽象基类（至少包含一个纯虚函数），抽象基类智能继承，继承后的派生类如果没有纯虚函数可以正常实例化

* 将构造函数设为私有(private/protected)
	* protected继承后，派生类可以正常实例化

* 不运行在类外创建对象，只在类内部创建对象
	* 类内部的对象是唯一的，或者所有对象的状态都是共享的，您可以将这个对象定义为类的静态成员变量。这样，对象就会在类被加载到内存时创建，并且**只能有一个实例**（除非您使用特殊的技巧，如单例模式的变体）。

```c++
class MyClass {
private:
    MyClass() {} // 私有构造函数

public:
    static MyClass createInstance() {
        return MyClass(); // 内部创建对象
    }
};
```

​           如果您需要在类外部有某种方式能够访问或创建类的对象，但又不想公开构造函数，您可以使用友元类或友元函数。然而，这种方法并不完全阻止在类外部创建对象，而是限制了能够创建对象的代码的范围

**友元类或函数：** 友元类或函数可以访问类的私有成员，因此可以允许特定的类或函数来创建对象。

```c++
cppCopy codeclass MyClass {
private:
    MyClass() {} // 私有构造函数

    friend class MyFriendClass;
    friend void createMyClassObject();
};

class MyFriendClass {
public:
    void createObject() {
        MyClass obj; // 在友元类中创建对象
    }				// 即使可以创建MyClass的对象，这些对象仍然是临时的，并且不会在类外部持续存在 
};					// 除非它们被传递给其他函数或存储在外部容器中。
void createMyClassObject() {
    MyClass obj; // 在友元函数中创建对象
}
```



## **12.6、类对象的大小和什么有关**

* 类的非静态成员变量
* 内存对齐另外分配的空间大小
* 虚函数指针会在类对象中
* 该类是派生类时，派生类继承基类部分的数据成员也会在派生类的空间中。
* 对逻辑上大小为0的class，编译器会默认设定大小为1



# 13、大小端存储

小端存储：字数据的高字节存在高地址，低字节存在低地址（栈）

大端存储：字数据的高字节存在低地址，低字节存在高地址（堆）

* socket编程需要将操作系统多用的小端存储的IP地址转为大端存储
	* **网络字节序**：TCP/IP协议规定，在网络上传输的数据必须采用网络字节序，即大端模式（Big-Endian）。这是为了确保不同硬件平台之间能够无歧义地交换数据。
	* **主机字节序**：然而，不同的计算机系统和处理器架构可能采用不同的字节序来存储数据，即大端模式或小端模式（Little-Endian）。例如，Intel处理器通常采用小端模式，而某些其他处理器或系统可能采用大端模式。
	* 在Socket编程中，通常使用以下函数来进行字节序的转换：
		* **htonl()**：将主机无符号长整型（unsigned long）数据转换为网络字节序。
		* **htons()**：将主机无符号短整型（unsigned short）数据转换为网络字节序。
		* **ntohl()**：将网络字节序的无符号长整型数据转换为主机字节序。
		* **ntohs()**：将网络字节序的无符号短整型数据转换为主机字节序。

**union联合体判断大小端存储：**

* 这里注意的是union共享一段内存，这里的共享不是说多个成员同时装入一个共用体变量，而是能赋值任意类型的值，但同一时间只能赋值一个，后面在赋值会被覆盖。

```C++
union un1{
	short a;
    char ch[sizeof(short)];
};
int main(){
	un1 vlaue;
    value.a = 0X1234;  //两个字节
    if(value.ch[0] == 12) //大端存储
    if(value.ch[0] == 34) //小端存储
}
```



# 14、标准异常

C++中对多个异常的处理：

引入异常处理机制：执行一个函数的过程中发现异常，可以不用再本函数内立即进行处理，而是立即抛出该异常，让函数的调用者直接或者间接处理这个问题。

异常处理机制包含三个模块：try(检查)、throw(抛出)、catch(捕获)。

## 14.1、try、throw、catch关键字

* try语句包含可能会引发异常的代码
* catch语句用于捕获和处理异常
	* **严格的类型匹配**：try中的异常类型要与catch捕获的异常类型相同或其父类型。
* throw显式的抛出异常

```c++
class myexception{
public:
    myexception(){};
    myexception(const myexception &e){}
    ~myexception(){};
}

double test(double x,double y){
	if(y == 0){
		throw y;
	}
	return x/y;
}

int mydivide(int a,int b){
	person p1;  //栈解旋，从try代码块开始到throw抛出异常之前，所有栈上的数据都会被释放掉，释放的顺序和构造顺序相反（栈的LILO）
    person p2;
    throw;
}

void dowork(){
	throw myexception(); //抛出匿名的异常自定义类型对象-->调用默认构造函数
}
int main(){
	try{  //定义异常
		test(2,3);
        dowork();
	}
	catch(double){  //抛出的异常是double类型-->捕获异常
		cout << " 不对"  << endl;
	}
    catch(...){} //...代表可以捕获任何异常（不推荐）
    catch(){
		throw; //捕获到了异常，但是不想处理，继续上上抛出这个异常
    }
    //自定义数据类型的捕获
 	catch(myexception e){ //以值的方式调用匿名对象，会调用拷贝构造函数,效率低
        cout << "自定义异常类型捕获" << endl;
    }
    catch(myexception &e){} //用&e来接受抛出的匿名对像myexception,等价于(&e=myexception();)只会调用默认构造函数，效率高
    catch(myexception *e){} //用*e来接收匿名对象，必须抛出匿名对象的地址-->throw &myexception();
    						//*e:这样对象会提前释放掉，不能非法操作。
}
```

这里对自定义类型myexception的抛出和catch的接收：

![image-20240402172002834](全栈_C++.assets/image-20240402172002834.png)

​			当抛出myexception()对象时，可以用e/&e的方式去接收

​			抛出&myexception()的对象时用*e的方式去接受

​			&e接收等价于&e=myexception()；相当于起别名，不会提前释放掉对象

​						可以throw new myexception();在catch中delete e;

​			*e只是作为一个指针指向匿名对象，表达式完毕便会提前释放掉



## 14.2、函数的异常声明列表

```c
int func() throw(int，double,A,B,C){....};  //int、double、A、B、C是异常类型的名称，它们表示函数func可能抛出的异常类型。当指定没有类型，能抛出的异常只能这一类。
```



## 14.3、异常的多态使用

* 提供基类异常类
	* class basexception
	* 纯虚函数 printf
* 子类空指针异常和越界异常继承基类
* 重写printf

```c++
//异常基类
class basexception{
public:
    virtual void printf() = 0; //纯虚函数
};
//空指针异常
class NULLexception:public basexception{
public:
    virtual void printf() override{  //重写
        cout << "空指针异常" << endl;
    }
};
//越界异常
class outofrange:public basexception{
public:
    virtual void printf() override{
        cout << "越界异常" << endl;
    }
};

void dowork(){
    throw NULLexception(); //抛出子类空指针异常
}
void test(){
    try{
        dowork();
    }
    catch(basexception &e){ //相当于父类引用接收子类对象
        cout << e.printf() << endl;  //一个printf有多种形态
    }
}
```



## 14.4、C++标准异常类exception

* 在C++中，`std::exception` 类是所有标准异常类的**基类**，它定义在头文件 `<exception>` 中。`std::exception` 类提供了一个虚函数 `what()`，该函数返回一个表示异常信息的 `const char*` 类型的字符串。这个字符串通常用于描述发生了什么错误或异常情况。
* 当你需要自定义异常类时，通常会从 `std::exception` 类派生，这样你的异常类就可以继承 `what()` 方法，并可能添加额外的成员变量或方法来提供更详细的错误信息或异常处理逻辑。

![image-20240402173325004](全栈_C++.assets/image-20240402173325004.png)

```c++
#include<stdexcept>
class person{
public:
    int age;
	person(int age){
        if(age <0 || age > 150)
        	throw out_of_range("这不是人");
        else
            this->age = age;
    }
};
void test(){
    try{
        person p(151);
    }
    catch(out_of_range &e){
    //catch(exception &e)  //同样可以用基类引用接收-->多态
        cout << e.what() << endl;  //what()可以获取到out_of_range的字符串
    }
}
//继承异常基类
class myexception:public exception{
    
}
```



# 15、智能指针

## 15.1、C++堆栈内分配流程与内存泄漏

概念：当程序未能释放掉不再使用的内存的情况

当new了一片空间，但是不delete指针，释放空间，便会造成**内存泄漏**，也就是说当申请了一片内存空间，但在使用完后不进行显式的释放，这块内存不能被再次使用。

```c++
void func(int *a){
	a = new int(10);
}
int main(){
	int c=30; 
	func(&c);
	return 0;
}
```

![image-20240403162825440](全栈_C++.assets/image-20240403162825440.png)

​	     在main中定义的代码和调用的函数，通常会被存储在栈中，在栈中创建了常量c = 30，然后将地址c的地址传递给函数func，此时a中存放了c的地址，*a指向c的内存空间。而a利用new在堆上重新申请了一片内存空间，申请并构造完后返回指针给a，a中的地址便发生变化指向了新的内存空间（堆）。当func(&c)执行完毕，由操作系统释放掉，那么a的空间也会被释放掉，此时没有指针指向堆区新申请的空间了，**此时没有delete便会内存泄漏。**

代码改进：

```c++
void func(int **a){ //a里面存放的c指针的地址
	*a = new int (10);  //在对上开辟一段内存，并将地址赋值给*a，但是此时a中的地址是c，*a也指向c，因此会将堆内存的地址给c
}
int main(){
	int *c = nullptr;
	func(&c);  //这里是取指针c的地址，作为实参
}
//当func执行完成后，内存回收，但是c里面已经是新开辟的堆内存的地址，*c指向堆，这里形参int* *a的作用就是用*a指向的位置来接收new返回指针，而不是a本身用来存放指针，因此即使func释放了，也会有指针指向堆内存，。
```

![image-20240403202829099](全栈_C++.assets/image-20240403202829099.png)

**内存泄漏的避免：**

* new 和delete成对出现
* 对象数组的释放一定用delete[]
* 多态时，一定要将基类的析构函数声明为**虚函数**。
* 使用智能指针



## 15.2、智能指针

* 智能指针是类模板，在栈上创建智能指针对象，把普通指针交给智能指针对象
* 智能指针过期时，调用析构函数释放普通指针的内存
* 智能指针就是类，类中有一个成员，管理着原始指针，负责自动释放动态分配的对象，防止堆栈溢出。
	* 智能指针就是⼀个类，当超出了类的 作⽤域时，类会⾃动调⽤析构函数，析构函数会⾃动释放资源。所以智能指针的作⽤原理就是 在函数结束时⾃动释放内存空间，不需要⼿动释放内存空间

**智能指针删除器：**

* 在默认情况下，智能指针过期的时候，用 delete 原始指针;释放它管理的资源。
* 程序员可以自定义删除器，改变智能指针释放资源的行为。
* 删除器可以是全局函数、仿函数和 Lambda 表达式，**形参为原始指针**。
	* 自定义删除器的目的肯定是想在释放资源时，做点其他事情。

```c++
class A{
public:
	//自定义删除器
	void deletefunc(A *a){ //删除器，普通函数
		delete a;
    }
    struct deleteclass{ //删除器，仿函数
        void operator()(A *a){
		delete a;
        }
    };
    auto deletelamb = [](A *a){ //删除器，lambda表达式
		delete a;
    }; 
};

shared_ptr<A> p(new A("狗蛋"),deletefunc);
unique_ptr<A,decltype(deletefunc)*> p(new A("狗蛋"),deletefunc);
```



### 1、独占资源unique_ptr

#### 1.1、概念

* uniuqe_ptr独享它指向的对象，同时只有一个unique_ptr指向同一个对象
* **当unique_ptr被销毁时，指向的对象也被销毁**
	
* unique_ptr默认情况下大小等同于原始指针
	
* unique_ptr**不能使用拷贝构造函数，不可用于隐式转换初始化**,**只允许移动**,移动之后源指针被置空。
* unique_ptr作为继承层次结构中对象的工厂函数返回类型。
* 不能用unique_ptr管理不是new分配的内存
* **不能作为函数参数值传递**，只能引用和指针传递

![image-20240409100559242](全栈_C++.assets/image-20240409100559242.png)

```c++
#include<memory>
template<typename T,typename D = default_delete<T>>  //第一个参数是指针模板类型，第二个参数是指定删除器，默认为delete
class unique_ptr{
public:
private:
   pointer ptr; //内置指针，指向被管理的对象地址
}
//使用场景
class A{
public:
    string name;
    A(){cout << "构造函数" << endl;}
    ~A(){cout << "析构函数" << endl;}
}
A *p = new A("狗蛋"); //普通指针p，p表示被管理的指针，指向new出来的对象的地址
unique_ptr<A> pu(p); // 将p拷贝给pu，不能使用同一个普通指针初始化多个unique_ptr对象

unique_ptr<A> pu(new A("西施"));  //最常用的方法，通过匿名对象

unique_ptr<A> pu;
pu = unique<A>(new A("西施")); //匿名对象
unique_ptr<A> uptr = unique<A>(new A("西施"));
unique_ptr<A> pu= make_unique<A>("西施");


cout << pu->name << (*pu).name << endl; //智能指针重载了->和*
void func(unique_ptr<A> pu) //错误,不能作为函数参数值传递，只能引用和指针传递
    
void func(unique_ptr<A> *pu){ //正确-->传地址}
func(&pu); //调用
```



#### **1.2、使用方法：**

* 将一个unique_ptr赋值给另一个时，如果源unique_ptr是一个临时右值，编译可以通过，但是如果源unique_ptr将存在一段时间，编译器禁止这样做，一般用于函数的返回值

```c++
unique_ptr<A> p0(new A("西施"));
unique_ptr<A> p1;
p1 = p0; //错误,禁止拷贝构造
p0 = unique_ptr<A>(new A("西施")); //用匿名对象给p0赋值，匿名对象在此行代码完成后便会释放掉
```

* 将unique_ptr赋值为nullptr会释放对象

```c++
unique_ptr<A> p0(new A("西施"));
p0 = nullptr; //释放-->构造+析构
```

* release()释放对原始指针的控制权，将unique_ptr**置空**，返回裸指针。（可用于将unique_ptr传递给子函数，子函数将负责释放对象）
	* p.get()：
		* 返回裸指针
		* 能获取到类中管理的原始指针指向的地址

	* &pu:unique_ptr申请一个对象也有自己的地址，和管理的指针的地址不同


```c++
void func(const unique_ptr<A> *a){} //不进行显式的释放，不对unique_ptr进行负责
void func2(unique_ptr<A> *a){
	delete a;  //对指针负责，由函数来释放指针
}
unique_ptr<A> p0(new A("西施"));
func1(p0.get());  //func需要一个指针，不对unique_ptr进行负责
func2(p0.release());  //func2需要一个指针，对unique_ptr进行负责
```

* std::move()可以转移对原始对象的控制权（可用于将unqiue_ptr传递给子函数，子函数形参也是unique_ptr）

```c++
void func4(unique_ptr<A> a){}
fun4(std::move(p0)); //func4需要一个指针，对unique_ptr进行负责,将原始指针的控制权交给func4函数中的形参
```

* reset()释放对象

```c++
p0.reset(); 
p0.reset(nullptr); //释放p0对象指向的资源对象
p0.reset(new B("狗蛋")); //释放p0对象指向的资源对象，同时指向新的对象
```

* swap()：交换两个unique_ptr的控制权

```c++
void swap(unique_ptr<T> &_right);
```

* unique_ptr也可以像普通指针那样，当指向一个类的继承体系的基类对象时，也具有多态性质，如同使用裸指针管理基类对象和派生类对象那样

* unique_ptr**不是绝对安全的**，程序中通过**exit()**退出，全局的unique_ptr可以自动释放，但是局部的unique_ptr无法释放(无法析构，只会构造)

```c++
unique<A> p(new A("西施"));
void test(){
	unique<A> p1(new A("西施"));
}
int main(){
	test();
	exit(0); //全局p可以调用构造和析构，test()局部中的p1只能调用构造
	//return 都可以释放
}
```

* unique_ptr提供了支持数组的具体化版本

数组版本的unique_ptr，重载了操作符[]，操作符[]返回的是引用，可以作为左值使用

```c++
unique_ptr<int[]> arr(new int[3]{33,22,11});
unique_ptr<A[]> arr2(new A[2]{string("西施"),string("狗蛋")});
cout << arr[0] << endl;
cout << arr[0].name << endl;
```



### 2、共享指针shared_ptr

#### 2.1、概念

* shared_ptr**共享它指向的对象，多个shared_ptr指向相同（关联）的对象**，在**内部采用计数机制**来实现。
	* 当新的shared_ptr与对象相关联时，引用计数增加1
	* 当shared_ptr超出作用域时，引用计数减1，当引用计数为0时，则表示没有任何shared_ptr与对象关联，则释放该对象
	* p.use_count()获取引用计数值

```c++
//使用场景
class A{
public:
    string name;
    A(){cout << "构造函数" << endl;}
    ~A(){cout << "析构函数" << endl;}
}
//调用
//初始化
A *p = new A("狗蛋");
shared_ptr<A> p0(p); //拷贝初始化
shared_ptr<A> p0 = make_shared<A>("西施");  //常用

shared_ptr<A> p0(new A("张三"));  //匿名初始化
shared_ptr<A> p1(p0);  //用已经存在的shared_ptr初始化p1，计数+1
shared_ptr<A> p2 = p1; //隐式拷贝，计数+1

cout << p0.use_count(); //获取引用计数值-->3
cout << p0->name;
```



#### **2.2、使用方法：**

* 同样重载了*和->重载运算符，可以像指针一样使用shared_ptr
* use_count()：返回引用计数器的值
* unique()方法，如果use_count为1返货true，否则返回false
* shared_ptr**支持赋值**，左值的shared_ptr的计数器将减一，右值的shared_ptr的计数器值将加一。
	* 赋值操作会导致原来`ptr1`指向的对象（如果引用计数为0）被销毁，且`ptr1`开始指向`ptr2`指向的对象，并增加该对象的引用计数。


```c++
shared_ptr<A> pa0(new A("狗蛋"));				   // 匿名初始化
shared_ptr<int> ptr1 = make_shared<int>(10);   	//标准初始化
std::shared_ptr<int> ptr2 = ptr1;  				// 拷贝
ptr1 = ptr2; 									// 赋值

shared_ptr<A> pa1 = pa0; //计数+1
shared_ptr<A> pa2 = pao;
cout << pa0.use_count(); //3

shared<A> pb0(new A("西施"));
shared_ptr pb1 = pb0; //计数+1
cout << pb0.use_count(); //2

pb1 = pa1;
cout << pa0.use_count; //4
cout << pb0.use_count; //1
pb0 = pa0; //当我再次指定时，已经没有pb指向西施了，全都指向狗蛋，此时，pb0在指向资源狗蛋的同时，释放资源西施

// 作为函数参数
void myFunc(std::shared_ptr<int> ptr) {  
    // 在函数内部，ptr的引用计数不会改变（除非有其他操作）  
    std::cout << "Inside myFunc, ptr reference count: " << ptr.use_count() << std::endl;  
}
// 作为函数返回值
std::shared_ptr<int> createPtr() {  
    return std::make_shared<int>(30);  
} 
// 将ptr1作为参数传递给myFunc  
myFunc(ptr1); 
// 使用createPtr函数返回一个新的shared_ptr  
std::shared_ptr<int> ptr2 = createPtr();  
```

* get()返回裸指针
* 不能使用同一个裸指针初始化多个shared_ptr
* 不能使用shared_ptr管理不是new分配的内存

**注意：**

* shared_ptr与unique_ptr不同，有拷贝构造函数和赋值运算符重载
* shared_ptr**没有release()函数**，因为多个指针共享一个对象，要不要释放对原始指针的控制权，不是由一个shared_ptr说了算的。
* std::move()可以转移对原始指针的控制权,还**可以将unique_ptr转移为shared_ptr;**
* **reset()可以改变与资源的关联关系**

```c++
p.reset(); 			   //解除与资源的关系，计数器-1
p.reset(new A("张三")); //解除与资源的关系，资源的引用计数减一。关联新的资源
```

* swap()：交换两个shared_ptr的控制权

```c++
void swap(shared_ptr<T> &_right);
```

* shared_ptr也可以像普通指针那样，当指向一个类的继承体系的基类对象时，也具有多态性质，如同使用裸指针管理基类对象和派生类对象那样

* shared_ptr**不是绝对安全的**，程序中通过**exit()**退出，全局的shared_ptr可以自动释放，但是局部的shared_ptr无法释放(无法析构，只会构造)

* shared_ptr提供了支持数组的具体化版本
	* 数组版本的shared_ptr，重载了操作符[]，操作符[]返回的是引用，可以作为左值使用
* shared_ptr的线程安全：
	* shared_ptr的引用计数本身是线程安全（引用计数时原子操作）
	* 多个线程同时读一个shared_ptr对象是线程安全的。
	* 如果多个线程同时对同一个shared_ptr对象进行读写，则需要加锁
	* 多线程读写 shared_ptr所指向的同一个对象，不管是相同的 shared_ptr对象，还是不同的shared_ptr对象，也需要加锁保护。

**shared_ptr什么情况下会自增：**

* **初始化、拷贝、赋值**
* **作为函数参数和返回值**
	* 当一个函数通过值返回一个`shared_ptr`时，如果该函数内部创建的`shared_ptr`在返回时仍然有效，并且被外部接收，那么接收到的`shared_ptr`将是一个新的实例，但它会指向相同的对象，并且会导致引用计数自增。





### 3、弱智能指针weak_ptr

shared_ptr计数器计数归0时，资源会释放掉，但是当出现**循环引用**时，计数器无法归0，资源无法释放掉。`std::weak_ptr`是一种不拥有其所指对象的智能指针，这意味着它不会增加对象的共享所有权计数。

* 循环引用：两个对象互相使用一个shared_ptr成员变量指向对方
* 实际上，如果不存在循环引用，也就不用使用weak_ptr
* 指向shared_ptr所管理的对象但不影响其生命周期。即**只引用，不计数**。

```c++
class A{
public:
	A(){}
	~A(){}
	shared_ptr<B> m_b; //A类的m_p成员指向B类的资源
};
class B{
public:
	B(){}
	~B(){}
	shared_ptr<A> m_a; //B类的m_p成员指向A类的资源
};

shared_ptr<A> pa = make_shared<A>("西施");
shared_ptr<B> pb = make_shared<B>("狗蛋");
pa->m_b = pb;  //指向pb:m_a,m_b-->2
pb->m_a = pa;  //指向pa:m_b,m_a-->2
//循环引用了,当出了main的作用域
//此时，出作用域，后构造的先析构，pb先析构，此时的析构会释放对象本身的智能指针，但是外界还有指针m_b指向对象pb，pb的内存空间pa还在用，因此pb对象不能被析构释放掉，因为还有指针指向它，计数为1，pa同理。pa与pb相互引用，都在等对方先释放
```

![image-20240423091440855](全栈_C++.assets/image-20240423091440855.png)

**引入weak_ptr:**

```c++
class A{
public:
	A(){}
	~A(){}
	weak_ptr<B> m_b; //A类的m_p成员指向B类的资源
};
class B{
public:
	B(){}
	~B(){}
    shared_ptr<A> m_a;
	//weak_ptr<A> m_p; //B类的m_p成员指向A类的资源
};

shared_ptr<A> pa = make_shared<A>("西施");
shared_ptr<B> pb = make_shared<B>("狗蛋");
pa->m_b = pb;
pb->m_a = pa;  //这里不再循环
```

#### 3.1、使用方法

* weak_ptr是为了配合shared_ptr而引入的，它**指向一个由shared_ptr管理的资源但是不影响资源的生命周期**，即将一个weak_ptr绑定到一个shared_ptr**不会改变shared_ptr的引用计数**

* 无论是否由weak_ptr指向，如果最后一个指向资源的shared_ptr被销毁，资源也就被释放掉

	![image-20240409164732471](全栈_C++.assets/image-20240409164732471.png)

```c++
if(pa->m_p.expired() == true)
    cout << "语句块内部：pa->m_p已过期"
else
    cout << pa->m_p.lock()->m_name << endl; //没过期便将weak_ptr用lock()提升为shared_ptr，这里在单线程中是安全的，但是这两步并不是原子的，可能在提升的过程中，资源已经被其他线程释放了，因此多线程不能这么实现
```



#### 3.2、线程安全

* weak_ptr不控制对象的声明周期，但是，他知道对象是否活着
* 用lock()函数把它可以提升为shared_ptr，如果对象还或者，返回有效的shared_ptr。如果对象已经死了，提升会失败，返回一个空的shared_ptr
* 提升的行为是lock()线程安全的	

多线程下：

```c++
shared_ptr<B> pp = pa->m_p.lock(); //将weak_ptr用lock()提升为shared_ptr
if(pp == nullptr)
    cout << "语句块内部：pa->m_p已过期"
else
    cout << pp->m_name << endl; //没过期便将weak_ptr用lock()提升为shared_ptr
```



### 4、auto_ptr

* 主要是为了解决，有异常抛出时发生内存泄漏的问题。因为异常发生无法正常释放内存。
	* `auto_ptr` 是 C++98 引入的一个智能指针类，设计用来自动管理动态分配的内存，以确保当对象超出作用域时，所管理的资源（在这里指的是动态分配的内存）会被自动释放，从而避免内存泄漏。
	* `auto_ptr` 通过**所有权模型**来管理资源。当你将一个 `auto_ptr` 对象赋值给另一个 `auto_ptr` 对象时，所有权会从源对象转移到目标对象，导致源对象变为空（即指向 `nullptr`）。
	* **不可与容器兼容**：由于 `auto_ptr` 的所有权转移特性，它不能与标准库中的容器（如 `std::vector`）兼容使用。当 `auto_ptr` 被用作容器的元素时，可能会导致所有权转移的问题，进而影响容器的正确性。
	* **不支持数组**：`auto_ptr` 只能用来管理单个动态分配的对象，而不支持动态分配的数组。虽然可以用它来管理一个动态分配的数组，但在删除时不会调用数组的 `delete[]`，而是 `delete`，这可能会导致未定义行为。


 ![image-20240423114914649](全栈_C++.assets/image-20240423114914649.png)

```c++
template<typename T>
class smart_ptr{
private:
	T * m_ptr;
public:
	explicit smart_ptr(T *ptr = nullptr):m_ptr(ptr){}
    ~smart_ptr(){
        delete m_ptr;
	}
    smart_ptr(const smart_ptr &) = delete;
    smart_ptr &operator=(const smart_ptr &) = delete;
    smart_ptr(smart_ptr && other){  //移动拷贝构造
		m_ptr = other.release();  //将other所有东西进行移动
    }
    smart_ptr &operator=(smart_ptr rhs){ //移动赋值运算符
		rhs.swap(*this); 
        return *this;
    }
    T *release(){  //转移auto的所有权
        T *ptr = m_ptr; //获取m_ptr
        m_ptr = nullptr; //m_ptr所有权交出后，置空
        return ptr;
    }
    T swap(smart &rhs){
		swap(m_ptr,rhs.m_ptr)
    }
    
    T* get() const{return m_ptr;}
    T& operator*() const{return *m_ptr;}
    T *operator->() const{return m_ptr;}
    operator bool() const{return m_ptr;}
};

class person{
    public:
    virtual ~person(){}
};
class student:public person{
public:
    ~student(){}
};
int main(){
    smart_ptr<student> ptr(new student);
    smart_ptr<student> p2;
    p2 = move(ptr);
}
```

* auto_ptr构造时取得某个对象的控制权，再析构时释放该对象，实际上是创建了一个auto_ptr类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放掉，所以不会有内存泄漏
* auto_ptr的构造函数为explicit，阻止了一般指针隐式转换为auto_ptr的构造，因此必须用auto_ptr的构造函数创建对象。
* auto_ptr对象析构会删除其所拥有的指针，所以避免多个auto_ptr指向同一对象
* atuo_ptr析构中，用的delete而不是delete[]，所以不能管理数组
* T *get()获取auto_ptr所拥有的指针，T *release()，释放auto_ptr所有权，并将所有用的指针反回



### 5、手写智能指针需要实现那些函数

构造函数、拷贝构造函数、赋值构造函数、析构函数、移动函数。



## **15.3、**RAⅡ

RAⅡ：资源获取即初始化，也就说在**构造函数中申请分配资源，在析构函数中释放资源**。

C++的语言机制保证了，当一个对象创建的时候，会自动调用构造函数，当对象超出作用域的时候会自动调用析构函数，所以，在RAⅡ的指导下，我们使用类来管理资源，将资源和对象的声明周期绑定。

而智能指针shared_ptr和unique_ptr即RAⅡ最具代表的实现，使用智能指针，可以实现自动的内存管理，不用担心忘记delete。



# 16、对象复用和零拷贝

## 16.1、对象复用

* 对象复用本质是一种设计模式：flyweight享元模式

* 通过将对象存储到**对象池**中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源

* 对象复用，或称为对象池化，是一种减少对象创建和销毁开销的技术。在程序设计中，频繁地创建和销毁对象会消耗大量的计算资源，特别是在需要创建大量相似对象的场景中。对象复用通过预先创建一组对象，并在需要时从池中取出对象使用，使用完毕后放回池中，而不是销毁它，从而避免了频繁的内存分配和回收操作。

	**优点**：

	* 提高性能：减少了因对象创建和销毁带来的时间开销。
	* 减少内存碎片：通过复用对象，可以减少因频繁的内存分配和回收导致的内存碎片。
	* 控制资源使用：可以更精确地控制系统中对象的数量，防止资源耗尽。

	**应用场景**：

	* 线程池
	* 数据库连接池
	* 图形界面的UI组件复用
	* 频繁创建和销毁相似对象的场景

	```c++
	// 假设有一个简单的类  
	class SimpleObject {  
	public:  
	    // 构造函数、析构函数等...  
	    SimpleObject() { /* 初始化对象 */ }  
	    ~SimpleObject() { /* 清理对象 */ }  
	      
	    // 对象的其他成员函数...  
	};  
	  
	// 简单的对象池类  
	class ObjectPool {  
	private:  
	    std::vector<SimpleObject*> pool; // 存储对象的指针  
	    std::mutex mtx; // 用于线程安全的互斥锁（如果需要的话）  
	  
	public:  
	    // 从池中获取对象，如果池为空则创建一个新对象  
	    SimpleObject* getObject() {  
	        std::lock_guard<std::mutex> lock(mtx); // 锁定互斥锁（如果需要）  
	        if (pool.empty()) {  
	            // 池为空，创建一个新对象  
	            return new SimpleObject();  
	        } else {  
	            // 从池中取出一个对象  
	            SimpleObject* obj = pool.back();  
	            pool.pop_back();  
	            return obj;  
	        }  
	    }  
	  
	    // 将对象放回池中  
	    void returnObject(SimpleObject* obj) {  
	        std::lock_guard<std::mutex> lock(mtx); // 锁定互斥锁（如果需要）  
	        // 假设对象可以被重置或重用（这里省略了重置逻辑）  
	        // ...  
	        pool.push_back(obj); // 将对象放回池中  
	    }  
	  
	    // 可能还需要其他成员函数，如清理池、限制池的大小等...  
	};  
	  
	// 使用对象池  
	int main() {  
	    ObjectPool pool;  
	  
	    // 获取对象  
	    SimpleObject* obj1 = pool.getObject();  
	    // 使用obj1...  
	  
	    // 将对象放回池中  
	    pool.returnObject(obj1);  
	  
	    // 再次获取对象，可能是之前放回池中的那个对象  
	    SimpleObject* obj2 = pool.getObject();  
	    // ...  
	  
	    // 注意：在这个简化的示例中，我们没有处理对象的销毁。  
	    // 在实际应用中，你可能需要在池被销毁时遍历并删除所有对象，  
	    // 或者使用智能指针来管理对象的生命周期。  
	  
	    return 0;  
	}
	```

	

## 16.2、零拷贝

* 零拷贝是一种数据传输技术，用于**减少数据在用户空间和内核空间之间的拷贝次数**，从而提高数据传输的效率。在传统的数据传输中，数据可能需要多次在内核空间和用户空间之间拷贝，这不仅增加了CPU的负担，也延长了数据传输的时间。
* 一种避免CPU将数据从一块内存拷贝到另一块存储的技术
* 可以减少数据拷贝和共享总线操作的次数

**实现方式**：

* **DMA（直接内存访问）**：通过DMA技术，数据可以直接在内存和硬件之间传输，无需CPU的参与。
* **映射用户空间的缓冲区到内核空间**：通过mmap等方式，将用户空间的缓冲区映射到内核空间，这样内核就可以直接操作这些缓冲区，避免了数据在用户空间和内核空间之间的拷贝。
* **网络传输中的零拷贝**：如Linux中的sendfile系统调用，可以直接在内核中从文件读取数据并发送到网络，避免了数据从内核缓冲区拷贝到用户空间，再从用户空间拷贝回内核空间的过程。

**优点**：

* 提高数据传输效率：减少了CPU的拷贝工作，加快了数据传输速度。
* 降低CPU使用率：CPU可以更专注于其他任务，而不是在数据拷贝上浪费资源。

**应用场景**：

* 高性能网络服务器
* 文件传输和备份系统
* 大规模数据处理和存储系统

```c++
#include <fcntl.h>  
#include <unistd.h>  
#include <sys/sendfile.h>  
#include <iostream>  
#include <cstring>  
  
// 这是一个简单的封装函数，用于执行sendfile调用  
// 注意：这个函数没有处理所有可能的错误情况  
ssize_t zero_copy_sendfile(int out_fd, int in_fd, off_t *offset, size_t count) {  
    return sendfile(out_fd, in_fd, offset, count);  
}  
  
int main() {  
    int in_fd = open("input.file", O_RDONLY);  
    if (in_fd == -1) {  
        std::cerr << "Failed to open input file" << std::endl;  
        return 1;  
    }  
  
    int out_fd = open("output.file", O_WRONLY | O_CREAT, 0644);  
    if (out_fd == -1) {  
        std::cerr << "Failed to open output file" << std::endl;  
        close(in_fd);  
        return 1;  
    }  
  
    off_t offset = 0; // 从文件的哪个位置开始读取  
    size_t bytes_to_copy = 1024 * 1024; // 假设我们想要复制1MB的数据  
  
    ssize_t bytes_copied = zero_copy_sendfile(out_fd, in_fd, &offset, bytes_to_copy);  
    if (bytes_copied == -1) {  
        std::cerr << "sendfile failed" << std::endl;  
    } else {  
        std::cout << "Copied " << bytes_copied << " bytes using zero-copy" << std::endl;  
    }  
  
    close(in_fd);  
    close(out_fd);  
  
    return 0;  
}
```



# 17、模板类

模板类的代码通常在.h中

* 模板类很特殊，由template<...>处理的任何东西都意味着**编译器在当时不为它分配存储空间**，其**一直处于等待状态直到被一个模板实例**告知，在编译器和链接器的某一处，有一机制能去掉指定模板的多重定义。

	* **链接器（Linker）**：
		* 连接器是将多个目标文件和库文件组合在一起，生成可执行文件的程序。
		* 在编译过程中，源代码通常会被编译成多个目标文件，每个目标文件包含一个或多个函数或变量的定义和实现。
		* 连接器的作用是解析目标文件之间的符号引用关系，将它们合并成一个单独的可执行文件。
		* 连接器还负责解析外部库文件的引用，并将它们链接到可执行文件中，以便程序能够调用库中的函数或变量。

* 当编译器只看到模板的声明时，他不能实例化该模板，只能**创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来**。

* 当编译器在编译过程中遇到模板的声明时，它会生成对应的符号表明这个模板的存在，但并不会生成该模板的实际代码。这样做的好处是可以避免在编译阶段生成大量相似的代码，而是将模板的实例化推迟到链接阶段。

* 然后，在**链接阶段，链接器负责解析这些模板的外部符号**，并找到对应的实例化定义。如果找不到对应的实例化定义，链接过程将失败，并生成链接错误。

	* 这里的理解是，假设在一个文件**test.h**中写了了一个模板类:

	```c++
	test.h
	template<typename T>
	class Array {
	private:
	    T* elements;
	    int size;
	public:
	    Array(int size);
	    ~Array();
	    T& operator[](int index);
	    int getSize() const;
	};
	
	template<typename T>
	Array<T>::Array(int size) : size(size) {
	    elements = new T[size];
	}
	```

	main.cpp

	```c++
	// main.cpp
	
	#include <iostream>
	#include "Array.h"  // 包含模板类的声明
	
	int main() {
	    Array<int> intArray(5);  // 创建一个存储 int 类型的数组
	    for (int i = 0; i < intArray.getSize(); ++i) {
	        intArray[i] = i * 10;
	    }
	    for (int i = 0; i < intArray.getSize(); ++i) {
	        std::cout << intArray[i] << " ";
	    }
	    std::cout << std::endl;
	
	    return 0;
	}
	```

	* 然后我在mian.cpp包含其声明#include<test.h>，编译器只会看到 `Array` 类的声明，不会生成模板的实际代码。然后，在链接阶段，连接器会解析 `Array<int>` 的实例化定义，并找到对应的模板实例化定义，例如 `Array<int>::Array(int)`、`Array<int>::operator[](int)` 等。连接器会将这些实例化定义（实例化是由编译器根据需求决定的）链接到可执行文件中，以便程序可以正确运行。
	* **但是**如果main.cpp中包含了#include<test.h>，且在文件中使用了 `Array<int>` ，但是在test.h中没有对模板进行实例化定义，此时便会出错。

* 这种延迟实例化的方式使得模板的编译速度更快，因为编译器只需处理模板的声明，而不需要生成模板的实际代码，这些代码将在链接时由连接器处理。



# 18、重载运算符

## 18.1、cout和printf有什么区别

* **cout**
	* cout是C++中的标准输出流，cout<<后可以跟不同的类型，是因为**cout<<已存在针对各种类型数据的重载，所以自动识别数据的类型**
	* 可以输出各种对象、容器和自定义类型，并且可以使用流操作符 `<<` 进行链式输出。
	* 输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。

* **printf:**
	* `printf` 是C语言中的标准输出函数，使用格式化字符串来指定输出格式，需要手动指定数据类型和格式控制符，
	* 是无缓冲输出，有输出立即输出



## 18.2、重载运算符

重新定义已有的运算符，使其适用于用户自定义的数据类型或者类对象。

* **只能重载已有的运算符**，对于重载的运算符，其优先级和结合律必须和内置类型一致，不能更改运算符个数。
* 引入重载运算符，可以实现类的多态。
* 当重载运算符**是成员函数时**，this绑定到左侧运算符对象，即**成员运算符的参数数量比操作数少一个，**但**至少含有一个类类型的参数**。
* 标运算符 `[]`必须是成员函数。
* **从参数的个数判断到底定义的是那种运算符**，当运算符既是一元运算符又是二元运算符（+，-，*，&）
	* 一元运算符是负号，二元运算符是减法



**两种重载方式**：成员运算符与非成员运算符

* **非成员运算符（友元）**：

```c++
class myclass {
public:
	friend myclass operator+(const myclass& a, const myclass& b);
    friend myclass operator-(const myclass &a.const myclass &b);
	friend ostream& operator<<(ostream& out, const myclass& a);
    
    friend myclass operator-(const myclass &a);       
public:
	int val;
	explicit myclass(int val) :val(val){} //explicit使用于单参数的构造函数
};

myclass operator+(const myclass& a, const myclass& b) {  //加法重载（二元运算符）
	return myclass(a.val + b.val);
}
myclass operator-(const myclass &a,const myclass &b){  //减法重载（二元运算符）
	return myclass(a.val-b.val);
}
myclass operator-(const myclass &a){  //减法重载（一元运算符）
	return myclass(-a.val);
    
};

ostream& operator<<(ostream& out, const myclass& a) {  //<<左移运算符重载
	out << a.val;
	return out;
}

```

**成员运算符**：

```c++
#include<iostream>
using namespace std;

class myclass {
private:
    int arr[10];
public:
	int val;
    
	myclass operator+(const myclass& b) {  //左侧绑定this指针对象val，二元运算符加法
		return myclass(val + b.val);
	}
    myclass operator-(const myclass &a){  //二元运算符减法
        return myclass(val-a.val);
    }
    myclas operator-(){
		return myclass(-val); //一元运算符减法
    }
    myclass &operator++(){  //自增前缀，没有参数
    	val++;  
    	return *this;
	}
	myclass &operator++(int){  //自增后缀，多了一个int参数，但是用的时候不传参
		val++;
    	return *this;
	}
    myclass &operator=(int i){  //赋值运算符
        val = i;
        return *this;  //返回值必须是this对象的引用
    }
    myclass &operator[](int index){
		return arr[index];
    } 
	friend ostream& operator<<(ostream& out, const myclass& a);
    
public:	
	explicit myclass(int val) :val(val){}
};

ostream& operator<<(ostream& out, const myclass& a) {  //<<不能作为成员运算符
	out << a.val;
	return out;
}

int main() {
	myclass a(3);
	myclass b(5);
	cout << a + b << endl; //加法运算符
    a++; //后缀自增运算符
    ++a; //前缀自增运算符
    a = 10; //赋值运算符
    myclass arr;
    arr[0] = 10; //下标运算符
}
```

![image-20240412153940948](全栈_C++.assets/image-20240412153940948.png)



**另外：**

* string s = “abc”; 其实，abc并不是string类型，这也是赋值运算符的功劳。
* 复制构造函数适用于创建时新对象的初始化，赋值运算符适用于已有对象的赋值。
	* 这里可以用explicit关键字，区分开，不允许用另一对象来初始化新对象



## 18.3、函数重载的匹配顺序

1. 函数名查找
2. 确定候选函数（参数匹配）
3. 寻找最佳匹配（尽可能少地进行类型转换，或者说尽可能精确地匹配实参类型和形参类型）



# **19、lambda表达式**

匿名函数/闭包，用于定义并创建匿名的函数对象，可以方便的让别的函数调用。

* 变量捕获：让匿名函数可以捕获、**修改（按照引用捕获）外部变量**
	* 写法：在[]内部写一些外部变量，在匿名函数内部可以进行操作运算
		* [&] **所有变量都按引用捕获**（引用传递），函数体内可以使用lambda所在范围内所有可见的局部变量
		* [=] 所有变量都**按值捕获**（值传递），函数体内可以使用lambda所在范围内所有可见的局部变量
		* [&,=N] 按值捕获N，其他变量都按照引用捕获
		* [this] 在类中**捕获当前实例的指针**，可以使用lambda所在类中的成员变量

![image-20240412192943322](全栈_C++.assets/image-20240412192943322.png)



```c++
auto f = [](int a,int b)->int{
	return a+b;
}
f(1,2); // 3
```

```c++
int N = 100,M = 10;
auto g = [N,&M](int i){
	M = 20;
	return N*i;
}
g(10); 	//1000
M; 		//20
//c++14新特性：参数列表支持auto
auto g = [&](auto i){
	M = 20;
    return N*i;
}
```





# 20 friend(友元)

* 打破了类的封装性和数据的隐藏性。
* 是C++提供的外部函数的一种辅助方法
* 友元提高程序的运行效率

友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。



## 20.1 友元函数

* 类中friend修饰的函数
	* `friend`关键字用于声明友元函数或友元类。当一个函数被声明为某个类的友元时，这个函数可以访问该类的所有私有（private）和保护（protected）成员，就像它是类的一个成员函数一样。但是，这个友元函数并不是类的成员函数，它可以在类定义之外定义，也不需要是任何类的成员函数。

* 普通函数是友元函数
* 友元赋予友元函数中的**对象**具有打破权限的一个功能，并不是能够直接访问类中的数据，因此要访问类中的数据，**必须传入一个对象或者定义一个对象。**
  * 以一个对象为参数或者在当前函数中定义的对象
  * **友元函数不属于任何类**，是定义在类外的函数，不受类的权限限定。
  * 必须是友元函数中的对象才可以访问类中的任何属性的数据成员，即使返回该对象也脱离了友元函数，不再具有友元属性。
  * **一个函数可以是多个类的友元函数**，但必须在每个类中进行声明。

```c++
class person{
public:
	friend int func(int x,person &per); //声明
    friend int func2(int x,person *per); //指针也可以实现友元，操作的是地址，和引用一样
    frined person * returnobject(); //直接返回友元对象
private:
	int age;
    void print_test(){
	cout << "你好" << endl;
    }
};
int func(int x,person &per){  //类外定义，传入对象，访问private成员
    per.age = x;
    per.print_test();
    person p; //创建临时对象也可以访问
    p.age = y;
    p.print_test();
	return per.age;
}
int func2(int x,person *per){  //类外定义，传入对象，访问private成员
    per->age = x;
    per->print_test();
    person *p =new person(); //new一个对象也可以访问
    p->age = y;
    p->print_test();
	return per.age;
}
person * returnobject(){ //返回友元中的对象变量
    person *p = new person();
    p->age = 18;
    return p;
}
int main(){
	person p;
    func(1,p);
    person p2 = new person();
    func2(2,p2);
    returnobject()->age; //错误的，无法访问private成员，当对象脱离友元函数后，便不具有友元打破封装的属性
    return 0;
}
```

**以另一个类的成员函数为友元函数**：

```c++
class student; //声明类的存在，防止友元声明报错，这和编译顺序有关
class person{
    friend void student::print(person &p);//另一类中要使用的话必须进行声明
public:
	string name;
private:
	void print(){}
};
class student{
public:
    void print(person &p){  //传入person类对象
		return p.print();
    }
};
```



## 20.2 友元类

* 类A声明类B为友元类，意味着**B类的成员函数**（不是B类的对象或B类的静态成员变量）可以访问A类的私有或保护成员。
  * 这种关系并不给予A类中的B类对象（或A类的任何其他对象）任何特殊权限来访问B类的私有或保护成员。
* A类的对象仍然无法直接访问B类的私有或保护数据，除非B类也声明A类为其友元类，或者这些数据通过B类的公有或保护接口暴露出来。
* 友元类中，类的组合形式也无视权限。
* 友元关系不具有继承性和传递性。

```c++
#include <iostream>
class person{
public:
    person(int age,string name):m_age(age),m_name(name){}
	friend class student;  //声明student友元类
private:
	int m_age;
	string m_name;
};
class student{
public:
    void show(int x,string str,person &p){
		p.m_age = x;
        p.m_name = str;
        person *p1= new person(); //同样可以创建临时对象
        p1->m_age = x;
        p1->m_name = str;
        cout << p.age << p.name << endl;
    }
    
};
int main(){
    class person per;
    class studen stu;
    stu.show(18,"wangbadan",per);
}
```

**组合的形式实现友元类：**

```c++
#include <iostream>
class person{
public:
    person(int age,string name):m_age(age),m_name(name){}
	friend class student;  //声明友元类
private:
	int m_age;
	string m_name;
};
class student{
private:
    int stu_id;
    person per; //组合声明
public:
	student(int age,string name,int id):per(age,name),stu_id(id){} //列表初始化
    void show(){
		per.m_age = 100;
        per.m_name = "wangbadan"; //可以直接访问private成员
    }
};
```

**互为友元类：**

* 这里需要注意的就是**编译顺序**
* 创建类对象去调用类的成员函数，必须在类的定义之后

```c++
class person{
public:
	friend class student;
    void print();
private:
	void per_show();
};
class student{
public:
	int stu;
	friend class person;
    void print(){
		person *p = new person();
        p->print();
    }
private:
	void stu_show(){}
};
void person::print(){  //通过person类调用student类的print()函数，这里一定要注意编译顺序，必须写到student类的后面
	student *stu = new student();
    stu->print(); 
}
```



## 20.3 为什么友元函数必须在类内声明

因为编译器必须能够读取这个结构的声明以理解这个数据类型的大小、行为等方面的所有规则。

有一条规则在任何关系都很重要，那就是**谁可以访问我的私有部分。**







# 21、左值和右值

## 21.1、左值和右值

左值和右值是表达式的分类，主要根据表达式的可寻址性和生命周期来区分。

左值：

* **有持久的存储位置（表达式结束后仍旧存在），可以被取址**
* 可以获取地址的表达式，能出现在赋值语句的左边，对该表达式可以进行赋值。

* 但是const修饰的表达式，可以取地址，但是在初始化之后便无法再进行赋值。
* 变量，数组元素、结构体/类的实例、函数返回值(引用/非常量对象)

右值：

* **临时性的、不再需要的表达式结果**
* **无法获取地址**的对象，由常量值、函数返回值（值类型，该值没有被用于初始化一个左值引用）、lamba表达式，函数参数（即使参数是右值引用）、通常的字面量等
* 无法获取右值的地址，但是可以进行改变，定义了右值的右值引用时就可以更改右值
	* 右值又分为纯右值和将亡值
		* 纯右值就是临时变量和不跟对象关联的字面量值
		* 将亡值就是要转移的对象



## **21.2、i++和++i**

**i++：**

* i++是右值
	* 在i++操作中，编译器会首先生成一份i的临时拷贝，然后才会对i进行递增，最后返回临时拷贝的资源，这个拷贝是一个临时对象，没有持久的存储位置。

**++i:**

* ++i是左值，直接递增后马上返回其自身

```c++
int get_val(){
	return x;  //右值
}
void set_val(int val){
    x = val; //x是左值，val右值
}
void set_val2(int && val); //val是右值
int main(){
    x++; //右值
    ++x; //左值
    int y = get_val(); //正确，y是左值，get_val()是右值（临时），无法取值
    set_val(6); //参数是右值
    set_val(x); //此时的参数val是左值
}
```



## 21.3**、左值引用和右值引用**

左值引用：

* 传统的c++引用(&)

	```c++
	int a = 10;
	int &ref = a;
	```

右值引用：

* 右值引用的目的是**通过移动语义来避免无谓拷贝问题**，通过**move语义可以将临时生成的左值中的资源无代价的转移到另一个对象中去**，通过**完美转发**来解决不能按照参数实际类型来转发的问题。这样可以避免内存空间的释放和分配，能够延长变量值的声明周期。

* 当一个右值（如字面常量、表达式返回值、函数返回值等）被右值引用时，**该右值引用的变量可以接管临时对象（右值）的资源（如堆内存、系统资源等），而不需要进行深拷贝。**这样，原始的临时对象在其生命周期结束时可以被安全地销毁，而不会影响到已经被右值引用变量接管的资源。这一过程通过浅拷贝实现，避免了深拷贝可能带来的额外空间和时间开销。

	```c++
	int &&ref = 10;
	int a = 20;
	int &&ref2 = std;:move(a);
	```

* 右值引用关联到右值时，右值被存储到特定的位置，右值引用指向该特定位置。
* 右值值引用不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值转换为右值。
* 通过右值引用的声明，右值有“重获新生”，其生命周期与右值引用类型变量的声明周期是一样的，只要该变量还活着，该右值临时变量将会一直存在下去
* 右值引用独立于左值和右值，即右值引用类型可能是左值也可能是右值
* T &&t在发生自动类型推断时，是左值还是右值取决于它的初始化

```c++
template<typename T>
void func(T && t){
	cout << t << endl;
}
int getint(){
	return 5;
}
int main(){
	int a = 10;
    int &b = a; //正确，a已经创建，左值初始化左值，b是左值引用
    int &c = 10; //错误，c是左值不能使用常量字面值右值初始化，10没有存储位置是临时的
    int &&ref = std::move(value); // 正确，ref是一个右值引用，绑定到value转换后的右值上
    int &&d = 10; //正确
    const int &f = 10; //正确，左值常引用相当于万能型，可以用左值或者右值初始化
    const int &f = a; //正确
    const int &&h = 10; //正确，右值常引用，但是h有固定地址，是左值
    const int &&h = a; //错误
    const int &aa = h; //正确
    int &i = getint(); //错误，左值不能用临时变量（右值）初始化
    int &&i = getint(); //正确
    func(10); //t是右值
    func(a);//t是左值
    return 0;
}
```









# YYY、特殊函数

## 1、offsetof宏

* 获取结构成员相对于结构开头的字节偏移量

```c++
#include<stddef.h>
struct S{
	int x;
	char y;
	int z;
	double a;
};
cout << offsetof(S,x) << endl; //0
cout << offsetof(S,y) << endl;  //4
cout << offsetof(S,z) << endl; //8
cout << offsetof(S,a) << endl; //16
```



## 2、两个浮点数的比较

对于两个浮点数的大小比较，不能直接用==，因为计算机存在误差，只能通过相减之后的绝对值与预先设定的精度进行比较。

```c++
#include <stdio.h>  
#include <math.h>  
#include <float.h> // 包含FLT_EPSILON等浮点数的特性  
  
int approximatelyEqual(double a, double b, double epsilon) {  
    return fabs(a - b) < epsilon;  
}  
  
int main() {  
    double x = 0.1;  
    double y = 0.3 / 3.0;  
    double epsilon = DBL_EPSILON; // DBL_EPSILON是double类型能表示的最小正数  
  
    if (approximatelyEqual(x, y, epsilon)) {  
        printf("x and y are approximately equal.\n");  
    } else {  
        printf("x and y are not approximately equal.\n");  
    }  
    return 0;  
}
```



## **3、main函数中的内存结构**

* main函数的返回值必须是int，这样返回值才能传递给程序激活者，标识程序正常退出
* 对于main(int argc,char *argv[])函数的参数处理，一般会调用**getopt()**函数处理。

```c++
int main(int argc,char *argv[]){}
//char *argc[]:需要输入argc个参数，每个参数都是char类型输入，一次存放在数组里，数组是argv[]，所有的参数在指针
//int argc：char *指向的内存中，数组的元素个数为argc个，第一个参数是程序的名称。
```



## 4、一个空类中默认会添加那些函数

```c++
empty()；//缺省构造函数
empty(const empty &);//缺省拷贝构造函数
~empty();//析构函数
empty &operator =(const empty &);//赋值运算符
```



## 5、strcy、memcpy、sprintf函数

* **strcpy**

	* 只复制字符串
	* 不需要指定长度，遇到被复制的字符的串结束符'\0'才结束，所以容易溢出

	```c++
	char source[] = "Hello, world!";
	char destination[20];
	strcpy(destination, source);
	```

* **strncpy**

  * 将指定长度的字符串复制到字符数组中

  * 将`src`所指向的字符串中以`src`地址开始的前`n`个字节复制到`dest`所指的数组中

  * `dest`必须有足够的空间放置n个字符。
    * 如果`src`字符串的长度小于`n`，那么`dest`的剩余部分将用'\0'填充。

    * 如果`src`字符串的长度大于或等于`n`，那么`dest`将不会以null字符结尾，这可能导致未定义的行为。


  ```c++
  char *strncpy(char *strDest,const char *strDrc ,int pos);
      char src[20] = "Hello, world!";  
      char dest[10];       
      strncpy(dest, src, 5);  
      dest[5] = '\0';  // 手动添加null字符  
  ```

  

* **memcpy**:

  * 可以赋值任意内容，两个对象是两个任意可操作的内存地址，例如字符数组、整型、结构体、类等
  * 根据第三个参数决定复制长度
  * 主要实现内存块间的拷贝

  ```c++
  char source[] = "Hello, world!";
  char destination[20];
  memcpy(destination, source, sizeof(source));
  ```

* **sprintf**

  * 源操作符对象可以是多种类型，目的操作对象是字符串

  * 实现其他类型到字符串的转化

  	```c
  	char str[100];
  	int num = 10;
  	sprintf(str, "The number is: %d", num);
  	```

  	

## 6、memset成员函数

* 数组初始化函数
* 直接对内存进行操作
* 对类中的int.char,struct等类型的变量也可以在构造函数中，将对象的内存全部置为0.
	* 类中**有虚函数时，不能这么初始化**
	* 类中**含有C++类型的对象不能这么初始化**
		* 这些对象可能包含复杂的构造函数、析构函数和成员变量。直接使用 `memset` 来初始化这些对象可能会跳过它们的构造函数调用，导致对象处于未定义状态。

```c++
memset(this,0,sizeof(*this))
```

```c++
#include<csting>
int a[10];
memset(a,0,sizeof(a));
struct list{
	int a;
    char b;
};
memet(&list,0,sizeof(list));
```





## 7、回调函数

callback

* 和普通函数没有本质区别
	* 对于普通函数而言，由程序员书写时，函数的定义和调用都由自己完成，定义和使用都是分离的
* 回调函数要求传入的参数是函数变量（把函数也当成一个变量）
	* 调用的函数跟不关心，函数调用的是什么，只需要知道再哪里调用即可
	* 通过函数指针调用
	* 回调函数是**由用户实现**的，**由内核执行**（信号）。

```C++
int applyOperation(int (*p)(int), int value) { //函数指针作为变元传递给函数
    int result = p(value);
    return result;
}

// 一个简单的函数，对输入值进行平方操作
int square(int x) {
    return x * x;
}
// 另一个简单的函数，对输入值进行立方操作
int cube(int x) {
    return x * x * x;
}

int main(){
    int inputValue = 5;
    applyOperation(square, inputValue); //将函数作为参数给另一个函数
    applyOperation(cube, inputValue);
    return 0;
}
```

* 当发生某件事时，系统或其他函数会自动调用你定义的一段函数
* 回调函数就相当于一个中断处理函数，由系统再符合你设定的条件时会自动调用。为此需要做三件事：
	* 声明
	* 定义
	* 设置触发条件，就是在**函数中把回调函数名转换为地址作为一个参数**，以便系统调用
* 回调函数就是一个**通过函数指针调用的函数，将函数的指针（地址）作为参数传递给另一个函数**，而这个指针被用为调用它所指向的函数时，这就是回调函数。



## 8、auto、decltype、decltype(auto)

### 8.1 、auto

可以让编译器替我们去分析表达式所属的类型，和原来那些只对应某种特定的类型说明符。

* auto让编译器通过初始值来进行类型推演，从而活得定义变量的类型，所以说**auto定义的变量必须有初始值**。
* auto推导是从左往右的，`auto x=1,y=4.2;`会报错，因为会先推导出x的类型int，再推导y的类型double，冲突了
* 在类或者结构体中非静态成员变量的类型不能是auto

```c++
//普通类型
int a = 1,b = 2;
auto c = a+b; //c:int

//const类型
const int a = 1;
auto b = a; //a是顶层const，会被忽略，因此b是int类型
auto c = &a; //a是一个常量，对常量取地址是一种底层const，所以c是const int*类型
const auto d = a;  //当希望推断出来的const为顶层const，就需要在auto前加const

//引用和指针类型
int x = 2;
int &y = x;
auto z = y; //z是int类型
auto &p = y; // p是int&类型
auto p2 = &x; //p2是int*类型

//万能引用
int i=5;
auto&& m = i;	// i是左值，m是int类型
auto&& j = 5;	// 5是右值，j是int类型

//数组或函数
int i[5];
auto m = i;	// m为int类型指针，指向数组i
```



### 8.2 、decltype

**引入的目的：**

有时我们希望，可以**从表达式中推断要定义变量的类型，但却不用表达式的值去初始化变量**。或者函数的返回值类型为某个表达式的值类型。

**引入的作用：**

**选择并返回操作数的数据类型**。在此过程中，**编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值**。

```c++
int func() {return 0};
int a = 0;

//普通类型
decltype(func()) sum = 5; //sum的类型式函数func的返回值类型int，但是不会实际调用func只是分析其返回值类型
decltype(a) b = 5; //a:int-->b:int


//const类型,无论是顶层const还是底层const，decltype都会保留
const int c = 3;
decltype(c) a = 5; //顶层const
int e = 5;
const int *f = &e;
decltype(f) g = f; //g是底层const

//引用和指针类型,表达式是引用类型，decltype也是引用类型
const int e = 5;
int &a = e;
decltype(a) b = 5;  //b是引用类型int&

//当表达式是引用类型，但是想要得到这个引用所指向的类型，需要修改表达式
const int e = 5;
int &a = e;
decltype(a+0) b = 5;  //b是int类型

//对指针的解引用操作返回的是引用类型
int i= 3,j = 6,*p = &i;
decltype(*p) t = j; //t是int&类型，t和j绑定在一起

//如果一个表达式不是引用，但是我们需要推断引用，那么可以加上一对括号，就可以变为引用类型
int i= 3；
decltype((i)) j = i; //j是int&类型和i绑定在一起。
```

**decltype(auto)**：

可以用来声明变量以及指示函数返回类型。

在使用时，会将“="左边的表达式替换为auto，再根据decltype的语法规则来确定类型。

```C++
int e = 1;
const int *f = &e; //底层const
decltype(auto) j = f; //j：const int*，指向e
```

 

## 9、默认实参

在C++中，默认实参（Default Arguments）允许你为函数参数指定默认值。这样，在调用函数时，如果某些参数被省略，编译器将自动使用这些默认值。这可以使得函数的使用更加灵活和方便，尤其是在处理具有多个可选参数的函数时。

```c++
// 函数声明  
void func(int a, int b = 0, int c = 0);  
  
// 函数定义  
void func(int a, int b = 0, int c = 0) {  
    // 函数体  
    // 使用a, b, c  
}
```

使用：

* 调用函数时，可以省略具有默认值的参数。
* 如果提供了参数值，则使用提供的值，而不是默认值。
* 默认值只在函数声明中指定一次，然后在定义中（如果有的话）省略。

```c++
func(10); 			// 调用时省略了b和c，它们将使用默认值0  
func(10, 20); 		// 调用时省略了c，c将使用默认值0  
func(10, 20, 30); 	// 调用时提供了所有参数值
```

**注意事项：**

* 在函数声明或定义时，可以在参数列表的末尾为参数指定默认值。注意，**一旦开始为某个参数指定默认值，那么它之后的所有参数都必须有默认值。**
* 默认值必须是常量表达式，这意呀着它们必须在编译时就能确定其值。
* 默认值可以是全局变量、静态变量、字面量或常量表达式的结果，但不能是局部变量或非常量表达式的计算结果。
* 可以在函数声明中指定默认值，然后在定义中省略它们，但不允许在定义中指定而在声明中省略。
* 如果函数在多个文件中使用，通常只在头文件中（即函数声明处）指定默认值，以避免在多个源文件中重复指定。
* 默认值只在函数被调用时起作用，如果函数内部修改了参数的值，这不会影响默认值本身。
* 默认值可以引用之前已经声明的参数，但必须是之前已经声明的参数，且不能是函数内的局部变量。

**虚函数默认实参应用：**

```c++
class base{
	virtual void f(int a = 7){std::cout << " Base" << a << std::endl;}
};
class Derived:Base{
    void f(int a) override {std::cout<< "Brived" << a << std::endl;}
};
int main(){
    std::unique_ptr<Base>ptr(new Derived);
    ptr->f();			// Drived 7
}
```

**解释:**虚函数的覆盖函数不会从基类定义获得默认实参，而在进行虚函数调用时，默认实参根据对象的**静态类型**确定，因此a会输出7
